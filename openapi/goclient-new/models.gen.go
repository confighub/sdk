// Copyright (C) ConfigHub, Inc.
// SPDX-License-Identifier: MIT

// Package goclientnew provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package goclientnew

import (
	"encoding/json"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ActionResultType.
const (
	ActionResultTypeApplyCompleted    ActionResultType = "ApplyCompleted"
	ActionResultTypeApplyFailed       ActionResultType = "ApplyFailed"
	ActionResultTypeApplyWaitFailed   ActionResultType = "ApplyWaitFailed"
	ActionResultTypeDestroyCompleted  ActionResultType = "DestroyCompleted"
	ActionResultTypeDestroyFailed     ActionResultType = "DestroyFailed"
	ActionResultTypeDestroyWaitFailed ActionResultType = "DestroyWaitFailed"
	ActionResultTypeImportCompleted   ActionResultType = "ImportCompleted"
	ActionResultTypeImportFailed      ActionResultType = "ImportFailed"
	ActionResultTypeNone              ActionResultType = "None"
	ActionResultTypeRefreshAndDrifted ActionResultType = "RefreshAndDrifted"
	ActionResultTypeRefreshAndNoDrift ActionResultType = "RefreshAndNoDrift"
	ActionResultTypeRefreshFailed     ActionResultType = "RefreshFailed"
)

// Defines values for ActionStatusType.
const (
	ActionStatusTypeCanceled    ActionStatusType = "Canceled"
	ActionStatusTypeCompleted   ActionStatusType = "Completed"
	ActionStatusTypeFailed      ActionStatusType = "Failed"
	ActionStatusTypeNone        ActionStatusType = "None"
	ActionStatusTypePending     ActionStatusType = "Pending"
	ActionStatusTypeProgressing ActionStatusType = "Progressing"
	ActionStatusTypeSubmitted   ActionStatusType = "Submitted"
)

// Defines values for ActionType.
const (
	Apply     ActionType = "Apply"
	Destroy   ActionType = "Destroy"
	Finalize  ActionType = "Finalize"
	Heartbeat ActionType = "Heartbeat"
	Import    ActionType = "Import"
	NA        ActionType = "N/A"
	Refresh   ActionType = "Refresh"
)

// Defines values for MutationType.
const (
	Add     MutationType = "Add"
	Delete  MutationType = "Delete"
	None    MutationType = "None"
	Replace MutationType = "Replace"
	Update  MutationType = "Update"
)

// ActionResult defines model for ActionResult.
type ActionResult struct {
	Action *ActionType `json:"Action,omitempty"`

	// Data Configuration data of the Unit
	Data string `json:"Data,omitempty"`

	// LiveState Live state corresponding to the Unit
	LiveState string `json:"LiveState,omitempty"`
	Message   string `json:"Message,omitempty"`

	// Outputs Outputs resulting from applying the configuration data of the Unit
	Outputs string `json:"Outputs,omitempty"`

	// QueuedOperationID UUID of the operation corresponding to the action request
	QueuedOperationID openapi_types.UUID `json:"QueuedOperationID,omitempty"`
	Result            *ActionResultType  `json:"Result,omitempty"`
	RevisionNum       int64              `json:"RevisionNum,omitempty"`

	// SpaceID UUID of the Space of the Unit on which the action is performed
	SpaceID      openapi_types.UUID `json:"SpaceID,omitempty"`
	StartedAt    time.Time          `json:"StartedAt,omitempty"`
	Status       *ActionStatusType  `json:"Status,omitempty"`
	TerminatedAt time.Time          `json:"TerminatedAt"`

	// UnitID UUID of the Unit on which the action is performed
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`
}

// ActionResultType defines model for ActionResultType.
type ActionResultType string

// ActionStatusType defines model for ActionStatusType.
type ActionStatusType string

// ActionType defines model for ActionType.
type ActionType string

// ApiInfo Information provided to clients by the server.
type ApiInfo struct {
	// Build Build identifier for support cases.
	Build string `json:"Build,omitempty"`

	// BuiltAt The timestamp when ConfigHub was built in "2023-01-01T12:00:00Z" format for support cases.
	BuiltAt string `json:"BuiltAt,omitempty"`

	// ClientID ClientID for identity provider service.
	ClientID string `json:"ClientID,omitempty"`

	// Revision Service revision identifier for support cases.
	Revision string `json:"Revision,omitempty"`

	// WorkerPort Port number for the worker to connect to the server.
	WorkerPort string `json:"WorkerPort,omitempty"`
}

// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
// It acts as a bridge between ConfigHub and the infrastructure where configurations need
// to be applied. Bridge workers are responsible for executing configuration changes on
// remote targets and reporting status back to ConfigHub.
// When starting a bridge worker program, both the BridgeWorkerID and Secret are
// required for authentication with the ConfigHub server. These credentials allow the
// bridge worker to establish a secure connection and receive configuration actions.
type BridgeWorker struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// BridgeWorkerID Unique identifier for a Bridge Worker.
	BridgeWorkerID openapi_types.UUID `json:"BridgeWorkerID,omitempty"`

	// Condition Condition represents the worker's readiness state (Ready, NotReady, Unknown).
	Condition string `json:"Condition,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// LastHeartbeatMessage LastHeartbeatMessage contains the message from the last heartbeat.
	LastHeartbeatMessage string `json:"LastHeartbeatMessage,omitempty"`

	// LastHeartbeatReceivedAt LastHeartbeatReceivedAt is the time the last heartbeat was received.
	LastHeartbeatReceivedAt time.Time `json:"LastHeartbeatReceivedAt,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`
	ProvidedInfo   *WorkerInfo        `json:"ProvidedInfo,omitempty"`

	// Secret Secret is a unique secret token for the bridge worker.
	// It's auto-generated when the BridgeWorker entity is created and cannot be modified.
	// This field is output-only and used for authentication.
	// This secret is required when starting the bridge worker program.
	Secret string `json:"Secret,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// BridgeWorkerInfo defines model for BridgeWorkerInfo.
type BridgeWorkerInfo struct {
	// SupportedConfigTypes Configuration types supported by the BridgeWorker
	SupportedConfigTypes []ConfigType `json:"SupportedConfigTypes,omitempty"`
}

// BridgeWorkerStatus BridgeWorkerStatus represents the status information of a bridge worker within the system.
type BridgeWorkerStatus struct {
	// BridgeWorkerID Unique identifier for the Bridge Worker.
	BridgeWorkerID openapi_types.UUID `json:"BridgeWorkerID,omitempty"`

	// BridgeWorkerSlug Slug for the Bridge Worker.
	BridgeWorkerSlug string `json:"BridgeWorkerSlug,omitempty"`

	// BridgeWorkerStatusID BridgeWorkerStatusID is the unique identifier for the bridge worker status entry.
	BridgeWorkerStatusID openapi_types.UUID `json:"BridgeWorkerStatusID,omitempty"`

	// IPAddress IPAddress is the IP address from which the bridge worker is connecting.
	IPAddress string `json:"IPAddress,omitempty"`

	// OrganizationID OrganizationID is the unique identifier of the organization the bridge worker belongs to.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// SeenAt The timestamp when the bridge worker last responded in "2023-01-01T12:00:00Z" format.
	SeenAt time.Time `json:"SeenAt,omitempty"`

	// SpaceID SpaceID is the unique identifier of the space the bridge worker belongs to.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// Status Status indicates the current status of the bridge worker. Possible values include Connected, Disconnected, ActionSent, ActionResultReceived.
	Status string `json:"Status,omitempty"`
}

// ConfigType defines model for ConfigType.
type ConfigType struct {
	// AvailableTargets Targets known by the BridgeWorker
	AvailableTargets []TargetType2 `json:"AvailableTargets,omitempty"`

	// ProviderType Provider subtype of the configuration toolchain supported by the BridgegWorker
	ProviderType string `json:"ProviderType,omitempty"`

	// ToolchainType Configuration toolchain and format supported by the BridgeWorker
	ToolchainType string `json:"ToolchainType,omitempty"`
}

// DeleteResponse Response for successful delete operation
type DeleteResponse struct {
	// Message Response message.
	Message string `json:"Message,omitempty"`
}

// EventMessage defines model for EventMessage.
type EventMessage struct {
	Data  *string `json:"Data,omitempty"`
	Event *string `json:"Event,omitempty"`
}

// ExtendedBridgeWorker defines model for ExtendedBridgeWorker.
type ExtendedBridgeWorker struct {
	// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
	// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
	// It acts as a bridge between ConfigHub and the infrastructure where configurations need
	// to be applied. Bridge workers are responsible for executing configuration changes on
	// remote targets and reporting status back to ConfigHub.
	// When starting a bridge worker program, both the BridgeWorkerID and Secret are
	// required for authentication with the ConfigHub server. These credentials allow the
	// bridge worker to establish a secure connection and receive configuration actions.
	BridgeWorker *BridgeWorker `json:"BridgeWorker,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space       *Space `json:"Space,omitempty"`
	TargetCount int64  `json:"TargetCount,omitempty"`
}

// ExtendedLink defines model for ExtendedLink.
type ExtendedLink struct {
	// FromUnit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single "transaction"
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	FromUnit *Unit `json:"FromUnit,omitempty"`

	// Link Link connects two config Units in a dependency / producer-consumer relationship.
	// A Link indicates that config values Provided by the To Unit (the producer) may
	// satisfy config values Needed by the From Unit (the consumer), and should be attempted
	// to be matched before values Provided by other Units in the Space (if within the same
	// Space). Links must be created in the same Space as the From Unit.
	// They also imply an ordering when Applied or Destroyed as a Set.
	Link *Link `json:"Link,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// ToSpace The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	ToSpace *Space `json:"ToSpace,omitempty"`

	// ToUnit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single "transaction"
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	ToUnit *Unit `json:"ToUnit,omitempty"`
}

// ExtendedMutation defines model for ExtendedMutation.
type ExtendedMutation struct {
	// Link Link connects two config Units in a dependency / producer-consumer relationship.
	// A Link indicates that config values Provided by the To Unit (the producer) may
	// satisfy config values Needed by the From Unit (the consumer), and should be attempted
	// to be matched before values Provided by other Units in the Space (if within the same
	// Space). Links must be created in the same Space as the From Unit.
	// They also imply an ordering when Applied or Destroyed as a Set.
	Link *Link `json:"Link,omitempty"`

	// Mutation Mutation is a single source of mutation for a Revision.
	Mutation *Mutation `json:"Mutation,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Revision Revision is a historial view of a Config Unit.
	Revision *Revision `json:"Revision,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Trigger Defines an automated function invocation that executes in response to specific
	// Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
	// automated transformations, or other custom logic that should run when configuration
	// changes occur. Each Trigger is associated with a specific Space and can be configured
	// to execute on events.
	//
	// Triggers can be either validating (checking configuration validity without modifying it)
	// or mutating (making changes to the configuration). They can also be enforced (cannot be
	// overridden) or disabled.
	Trigger *Trigger `json:"Trigger,omitempty"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single "transaction"
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit *Unit `json:"Unit,omitempty"`
}

// ExtendedRevision defines model for ExtendedRevision.
type ExtendedRevision struct {
	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Revision Revision is a historial view of a Config Unit.
	Revision *Revision `json:"Revision,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single "transaction"
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit *Unit `json:"Unit,omitempty"`

	// User a User in Confighub.
	User *User `json:"User,omitempty"`
}

// ExtendedSet defines model for ExtendedSet.
type ExtendedSet struct {
	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Set A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
	Set *Set `json:"Set,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`
}

// ExtendedSpace defines model for ExtendedSpace.
type ExtendedSpace struct {
	GatedUnitCount           int64 `json:"GatedUnitCount,omitempty"`
	IncompleteApplyUnitCount int64 `json:"IncompleteApplyUnitCount,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization          *Organization `json:"Organization,omitempty"`
	RecentChangeUnitCount int64         `json:"RecentChangeUnitCount,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space                      *Space         `json:"Space,omitempty"`
	TargetCountByToolchainType map[string]int `json:"TargetCountByToolchainType"`
	TotalBridgeWorkerCount     int64          `json:"TotalBridgeWorkerCount,omitempty"`
	TotalUnitCount             int64          `json:"TotalUnitCount,omitempty"`
	TriggerCountByEventType    map[string]int `json:"TriggerCountByEventType"`
	UnappliedUnitCount         int64          `json:"UnappliedUnitCount,omitempty"`
	UnapprovedUnitCount        int64          `json:"UnapprovedUnitCount,omitempty"`
	UnlinkedUnitCount          int64          `json:"UnlinkedUnitCount,omitempty"`
	UpgradableUnitCount        int64          `json:"UpgradableUnitCount,omitempty"`
}

// ExtendedTarget defines model for ExtendedTarget.
type ExtendedTarget struct {
	// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
	// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
	// It acts as a bridge between ConfigHub and the infrastructure where configurations need
	// to be applied. Bridge workers are responsible for executing configuration changes on
	// remote targets and reporting status back to ConfigHub.
	// When starting a bridge worker program, both the BridgeWorkerID and Secret are
	// required for authentication with the ConfigHub server. These credentials allow the
	// bridge worker to establish a secure connection and receive configuration actions.
	BridgeWorker *BridgeWorker `json:"BridgeWorker,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Target Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
	Target *Target `json:"Target,omitempty"`
}

// ExtendedTrigger defines model for ExtendedTrigger.
type ExtendedTrigger struct {
	// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
	// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
	// It acts as a bridge between ConfigHub and the infrastructure where configurations need
	// to be applied. Bridge workers are responsible for executing configuration changes on
	// remote targets and reporting status back to ConfigHub.
	// When starting a bridge worker program, both the BridgeWorkerID and Secret are
	// required for authentication with the ConfigHub server. These credentials allow the
	// bridge worker to establish a secure connection and receive configuration actions.
	BridgeWorker *BridgeWorker `json:"BridgeWorker,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Trigger Defines an automated function invocation that executes in response to specific
	// Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
	// automated transformations, or other custom logic that should run when configuration
	// changes occur. Each Trigger is associated with a specific Space and can be configured
	// to execute on events.
	//
	// Triggers can be either validating (checking configuration validity without modifying it)
	// or mutating (making changes to the configuration). They can also be enforced (cannot be
	// overridden) or disabled.
	Trigger *Trigger `json:"Trigger,omitempty"`
}

// ExtendedUnit Unit with capability to extend additional related entities.
type ExtendedUnit struct {
	// ApprovedBy the users that have approved the latest revision of the config data.
	ApprovedBy []User `json:"ApprovedBy,omitempty"`

	// HeadMutation Mutation is a single source of mutation for a Revision.
	HeadMutation *Mutation `json:"HeadMutation,omitempty"`

	// HeadRevision Revision is a historial view of a Config Unit.
	HeadRevision *Revision `json:"HeadRevision,omitempty"`

	// LastAppliedRevision Revision is a historial view of a Config Unit.
	LastAppliedRevision *Revision `json:"LastAppliedRevision,omitempty"`

	// LatestUnitEvent UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks
	// the lifecycle of applying, destroying, or refreshing a Unit's configuration in the target
	// live system. The event captures the current status of the operation, any configuration
	// drift detected, and timing information about when the action started and completed.
	// Actions are atomic from ConfigHub's perspective but may involve multiple steps
	// in the connected Bridge. The status and drift detection help track the health
	// and consistency of the provisioned configuration compared to what is defined in the Unit.
	LatestUnitEvent *UnitEvent `json:"LatestUnitEvent,omitempty"`

	// LiveRevision Revision is a historial view of a Config Unit.
	LiveRevision *Revision `json:"LiveRevision,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Set A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
	Set *Set `json:"Set,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Target Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
	Target *Target `json:"Target,omitempty"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single "transaction"
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit       *Unit       `json:"Unit,omitempty"`
	UnitStatus *UnitStatus `json:"UnitStatus,omitempty"`

	// UpstreamSpace The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	UpstreamSpace *Space `json:"UpstreamSpace,omitempty"`

	// UpstreamUnit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single "transaction"
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	UpstreamUnit *Unit `json:"UpstreamUnit,omitempty"`
}

// FunctionArgument defines model for FunctionArgument.
type FunctionArgument struct {
	ParameterName *string                 `json:"ParameterName,omitempty"`
	Value         *FunctionArgument_Value `json:"Value,omitempty"`
}

// FunctionArgumentValue0 defines model for .
type FunctionArgumentValue0 = string

// FunctionArgumentValue1 defines model for .
type FunctionArgumentValue1 = int64

// FunctionArgumentValue2 defines model for .
type FunctionArgumentValue2 = bool

// FunctionArgument_Value defines model for FunctionArgument.Value.
type FunctionArgument_Value struct {
	union json.RawMessage
}

// FunctionInvocation defines model for FunctionInvocation.
type FunctionInvocation struct {
	// Arguments Function arguments
	Arguments []FunctionArgument `json:"Arguments"`

	// FunctionName Function name
	FunctionName string `json:"FunctionName,omitempty"`
}

// FunctionInvocationList defines model for FunctionInvocationList.
type FunctionInvocationList = []FunctionInvocation

// FunctionInvocationResponse defines model for FunctionInvocationResponse.
type FunctionInvocationResponse struct {
	// ConfigData The resulting configuration data, potentially mutated
	ConfigData string `json:"ConfigData,omitempty"`

	// ErrorMessages Error messages from function execution; will be empty if Success is true
	ErrorMessages []string              `json:"ErrorMessages"`
	Mutations     *ResourceMutationList `json:"Mutations"`

	// Mutators List of function invocation indices that resulted in mutations
	Mutators []int `json:"Mutators"`

	// OrganizationID ID of the Unit's Organization
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Output Output other than config data, as embedded JSON
	Output string `json:"Output,omitempty"`

	// OutputType Type of structured function output, if any
	OutputType string `json:"OutputType,omitempty"`

	// RevisionID ID of the Revision the configuration data is associated with
	RevisionID openapi_types.UUID `json:"RevisionID,omitempty"`

	// SpaceID ID of the Unit's Space
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// Success True if all functions executed successfully
	Success bool `json:"Success,omitempty"`

	// UnitID ID of the Unit the configuration data is associated with
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`
}

// FunctionInvocationsRequest FunctionInvocationsRequest represents a request to invoke a list of functions on the configuration data of the matching Units or Revision.
type FunctionInvocationsRequest struct {
	// CastStringArgsToScalars CastStringArgsToScalars indicates whether to expect string arguments and cast them to int and bool types as necessary.
	CastStringArgsToScalars bool `json:"CastStringArgsToScalars,omitempty"`

	// ChangeDescription ChangeDescription is a description of the change being made, if any.
	ChangeDescription string `json:"ChangeDescription,omitempty"`

	// CombineResults CombineResults indicates whether to combine the Outputs of all functions in the FunctionInvocations list. In the case of ValidationResult, the Passed results are ANDed together and a single ValidationResult is returned instead of a ValidationResultList. In the case of AttributeValueList and ResourceInfoList, the lists are concatenated. All output-generating functions must return the same OutputType, or only the first OutputType will be returned.
	CombineResults      bool                    `json:"CombineResults,omitempty"`
	FunctionInvocations *FunctionInvocationList `json:"FunctionInvocations"`

	// NumFilters NumFilters is the number of validating functions from the FunctionInvocations to treat as filters for the remaining functions in the list. In the case that the validation function does not pass, stop and don't execute the remaining functions, but don't report an error.
	NumFilters int `json:"NumFilters,omitempty"`

	// StopOnError StopOnError indicates whether to stop executing functions from the FunctionInvocations list on the first error, or to execute all of the functions and return all of the errors.
	StopOnError bool `json:"StopOnError,omitempty"`

	// UseFunctionWorker UseFunctionWorker indicates whether to use the function worker or the builtin function executor, which is the default. The FunctionInvocations are forwarded to the executor/worker, so all must be executable by the same executor/worker currently.
	UseFunctionWorker bool `json:"UseFunctionWorker,omitempty"`
}

// FunctionOutput defines model for FunctionOutput.
type FunctionOutput struct {
	// Description Description of the result
	Description string `json:"Description,omitempty"`

	// OutputType Data type of the JSON embedded in the output
	OutputType string `json:"OutputType,omitempty"`

	// ResultName Name of the result in kabob-case
	ResultName string `json:"ResultName,omitempty"`
}

// FunctionParameter defines model for FunctionParameter.
type FunctionParameter struct {
	// DataType Data type of the parameter
	DataType string `json:"DataType,omitempty"`

	// Description Description of the parameter
	Description string `json:"Description,omitempty"`

	// EnumValues List of valid enum values; applies to enum parameters
	EnumValues []string `json:"EnumValues,omitempty"`

	// Example Example value
	Example string `json:"Example,omitempty"`

	// Max Maximum allowed value; applies to int parameters
	Max int `json:"Max"`

	// Min Minimum allowed value; applies to int parameters
	Min int `json:"Min"`

	// ParameterName Name of the parameter in kabob-case
	ParameterName string `json:"ParameterName,omitempty"`

	// Regexp Regular expression matching valid values; applies to string parameters
	Regexp string `json:"Regexp,omitempty"`

	// Required Whether the parameter is required
	Required bool `json:"Required,omitempty"`
}

// FunctionSignature defines model for FunctionSignature.
type FunctionSignature struct {
	// AffectedResourceTypes Resource types the function applies to; * if all
	AffectedResourceTypes []string `json:"AffectedResourceTypes,omitempty"`

	// AttributeName Attribute corresponding to registered paths, if a path visitor; optional
	AttributeName string `json:"AttributeName,omitempty"`

	// Description Description of the function
	Description string `json:"Description,omitempty"`

	// FunctionName Name of the function in kabob-case
	FunctionName string `json:"FunctionName,omitempty"`

	// FunctionType Implementation pattern of the function: PathVisitor or Custom
	FunctionType string `json:"FunctionType,omitempty"`

	// Hermetic Does not call other systems
	Hermetic bool `json:"Hermetic,omitempty"`

	// Idempotent Will return the same result if invoked again
	Idempotent bool `json:"Idempotent,omitempty"`

	// Mutating May change the configuration data
	Mutating   bool            `json:"Mutating,omitempty"`
	OutputInfo *FunctionOutput `json:"OutputInfo,omitempty"`

	// Parameters Function parameters, in order
	Parameters []FunctionParameter `json:"Parameters"`

	// RequiredParameters Number of required parameters
	RequiredParameters int `json:"RequiredParameters,omitempty"`

	// Validating Returns ValidationResult
	Validating bool `json:"Validating,omitempty"`

	// VarArgs Last parameter may be repeated
	VarArgs bool `json:"VarArgs,omitempty"`
}

// FunctionWorkerInfo defines model for FunctionWorkerInfo.
type FunctionWorkerInfo struct {
	SupportedFunctions map[string]map[string]FunctionSignature `json:"SupportedFunctions"`
}

// ImportFilter defines model for ImportFilter.
type ImportFilter struct {
	Operator string   `json:"Operator,omitempty"`
	Type     string   `json:"Type,omitempty"`
	Values   []string `json:"Values,omitempty"`
}

// ImportOptions defines model for ImportOptions.
type ImportOptions map[string]interface{}

// ImportRequest defines model for ImportRequest.
type ImportRequest struct {
	Filters          []ImportFilter    `json:"Filters,omitempty"`
	Options          *ImportOptions    `json:"Options,omitempty"`
	ResourceInfoList *ResourceInfoList `json:"ResourceInfoList,omitempty"`
	Where            string            `json:"Where,omitempty"`
}

// Link Link connects two config Units in a dependency / producer-consumer relationship.
// A Link indicates that config values Provided by the To Unit (the producer) may
// satisfy config values Needed by the From Unit (the consumer), and should be attempted
// to be matched before values Provided by other Units in the Space (if within the same
// Space). Links must be created in the same Space as the From Unit.
// They also imply an ordering when Applied or Destroyed as a Set.
type Link struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// FromUnitID Unique identifier the Unit the Link initiates from. Links must be in the same space as the source unit.
	FromUnitID openapi_types.UUID `json:"FromUnitID,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// LinkID Unique identifier for a Link.
	LinkID openapi_types.UUID `json:"LinkID,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// ToSpaceID Unique identifier the Space of the Unit the Link targets.
	ToSpaceID openapi_types.UUID `json:"ToSpaceID,omitempty"`

	// ToUnitID Unique identifier the Unit the Link targets.
	ToUnitID openapi_types.UUID `json:"ToUnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// LinkExtended defines model for LinkExtended.
type LinkExtended struct {
	FromSpaceSlug string `json:"FromSpaceSlug,omitempty"`
	FromUnitSlug  string `json:"FromUnitSlug,omitempty"`

	// Link Link connects two config Units in a dependency / producer-consumer relationship.
	// A Link indicates that config values Provided by the To Unit (the producer) may
	// satisfy config values Needed by the From Unit (the consumer), and should be attempted
	// to be matched before values Provided by other Units in the Space (if within the same
	// Space). Links must be created in the same Space as the From Unit.
	// They also imply an ordering when Applied or Destroyed as a Set.
	Link        *Link  `json:"Link,omitempty"`
	ToSpaceSlug string `json:"ToSpaceSlug,omitempty"`
	ToUnitSlug  string `json:"ToUnitSlug,omitempty"`
}

// Mutation Mutation is a single source of mutation for a Revision.
type Mutation struct {
	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// EntityType The type of entity.
	EntityType         string              `json:"EntityType,omitempty"`
	FunctionInvocation *FunctionInvocation `json:"FunctionInvocation,omitempty"`
	LinkID             *UUID               `json:"LinkID,omitempty"`

	// MutationID Unique identifier for a Mutation.
	MutationID openapi_types.UUID `json:"MutationID,omitempty"`

	// MutationNum Sequence number for the Mutation.
	MutationNum int64 `json:"MutationNum,omitempty"`

	// OrganizationID Unique identifier for an Organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// ProvidedPath ProvidedPath is the path of the provided value used to satisfy a needed value if the change was made due to resolving a link.
	ProvidedPath     string        `json:"ProvidedPath,omitempty"`
	ProvidedResource *ResourceInfo `json:"ProvidedResource,omitempty"`

	// RevisionID Unique identifier of the corresponding Revision.
	RevisionID openapi_types.UUID `json:"RevisionID,omitempty"`

	// RevisionNum Sequence number of the corresponding Revision.
	RevisionNum int64 `json:"RevisionNum,omitempty"`

	// SpaceID Unique identifier for a space.
	SpaceID   openapi_types.UUID `json:"SpaceID,omitempty"`
	TriggerID *UUID              `json:"TriggerID,omitempty"`

	// UnitID Unique identifier for a Unit.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// MutationExtended defines model for MutationExtended.
type MutationExtended struct {
	// Mutation Mutation is a single source of mutation for a Revision.
	Mutation *Mutation `json:"Mutation,omitempty"`
}

// MutationInfo defines model for MutationInfo.
type MutationInfo struct {
	// Index Function index or sequence number corresponding to the change
	Index        int64         `json:"Index,omitempty"`
	MutationType *MutationType `json:"MutationType,omitempty"`

	// Predicate Used to decide how to use the mututation
	Predicate bool `json:"Predicate,omitempty"`

	// Value Removed configuration data if MutationType is Delete and otherwise the new data
	Value string `json:"Value,omitempty"`
}

// MutationMap defines model for MutationMap.
type MutationMap map[string]MutationInfo

// MutationType defines model for MutationType.
type MutationType string

// Organization The top-level container for an organization using ConfigHub.
type Organization struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// BillingAccountID Unique identifier for a billing account for the organization.
	BillingAccountID openapi_types.UUID `json:"BillingAccountID,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// ExternalID Unique identifier for the External Identity Provider record matching this organization.
	ExternalID string `json:"ExternalID,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// OrganizationExtended defines model for OrganizationExtended.
type OrganizationExtended struct {
	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`
}

// OrganizationMember a User given membership on the Organization
type OrganizationMember struct {
	// DisplayName Friendly name for the organization member User.
	DisplayName string `json:"DisplayName,omitempty"`

	// ExternalID Unique identifier for the External Identity Provider record matching this User.
	ExternalID string `json:"ExternalID,omitempty"`

	// ExternalOrganizationID Unique identifier for the External Identity Provider record matching this organization.
	ExternalOrganizationID string `json:"ExternalOrganizationID,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// ProfilePictureURL The URL to get the profile avatar picture of the User.
	ProfilePictureURL string `json:"ProfilePictureURL,omitempty"`

	// Slug Unique URL-safe identifier for the organization member User.
	Slug string `json:"Slug,omitempty"`

	// UserID Unique identifier for the organization member User.
	UserID openapi_types.UUID `json:"UserID,omitempty"`

	// Username Unique username for a User. Must be unique for all of ConfigHub.
	Username string `json:"Username,omitempty"`
}

// QueuedOperation QueuedOperation is a record of an operation to be done by a bridge worker.
type QueuedOperation struct {
	Action *ActionType `json:"Action,omitempty"`

	// BridgeWorkerID BridgeWorkerID is the unique identifier of the bridge worker that will process this operation.
	BridgeWorkerID openapi_types.UUID `json:"BridgeWorkerID,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// ExtraParams ExtraParams contains additional parameters for the operation in string format.
	ExtraParams string `json:"ExtraParams,omitempty"`

	// OrganizationID OrganizationID is the unique identifier of the organization this operation belongs to.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// QueuedOperationID QueuedOperationID is the unique identifier for the queued operation.
	QueuedOperationID openapi_types.UUID `json:"QueuedOperationID,omitempty"`

	// RevisionNum RevisionNum is the revision number this operation was performed on.
	RevisionNum int64 `json:"RevisionNum,omitempty"`

	// SpaceID SpaceID is the unique identifier of the space of the unit this operation is performed on.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// Status Status indicates the current status of the queued operation.
	Status string `json:"Status,omitempty"`

	// TargetID TargetID is the unique identifier of the target this operation is directed to.
	TargetID openapi_types.UUID `json:"TargetID,omitempty"`

	// UnitID UnitID is the unique identifier of the unit this operation is performed on.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// ResourceInfo defines model for ResourceInfo.
type ResourceInfo struct {
	// ResourceCategory Category of configuration element represented in the configuration data; Kubernetes and OpenTofu resources are of category Resource, and application configuration files are of category AppConfig
	ResourceCategory string `json:"ResourceCategory,omitempty"`

	// ResourceName Name of a resource in the system under management represented in the configuration data; Kubernetes resources are represented in the form <metadata.namespace>/<metadata.name>; not all ToolchainTypes necessarily use '/' as a separator between any scope(s) and name or other client-chosen ID
	ResourceName string `json:"ResourceName,omitempty"`

	// ResourceNameWithoutScope Name of a resource in the system under management represented in the configuration data, without any uniquifying scope, such as Namespace, Project, Account, Region, etc.; Kubernetes resources are represented in the form <metadata.name>
	ResourceNameWithoutScope string `json:"ResourceNameWithoutScope,omitempty"`

	// ResourceType Type of a resource in the system under management represented in the configuration data; Kubernetes resources are represented in the form <apiVersion>/<kind> (aka group-version-kind)
	ResourceType string `json:"ResourceType,omitempty"`
}

// ResourceInfoList defines model for ResourceInfoList.
type ResourceInfoList = []ResourceInfo

// ResourceMutation defines model for ResourceMutation.
type ResourceMutation struct {
	// Aliases Names (with scopes, if any) used in current and prior revisions of this resource
	Aliases map[string]map[string]interface{} `json:"Aliases,omitempty"`

	// AliasesWithoutScopes Names without scopes used in current and prior revisions of this resource
	AliasesWithoutScopes map[string]map[string]interface{} `json:"AliasesWithoutScopes,omitempty"`
	PathMutationMap      *MutationMap                      `json:"PathMutationMap,omitempty"`
	Resource             *ResourceInfo                     `json:"Resource,omitempty"`
	ResourceMutationInfo *MutationInfo                     `json:"ResourceMutationInfo,omitempty"`
}

// ResourceMutationList defines model for ResourceMutationList.
type ResourceMutationList = []ResourceMutation

// Revision Revision is a historial view of a Config Unit.
type Revision struct {
	// ApplyGates A map of "<trigger slug>/<function name>" to true of Triggers invoking validating functions that did not pass on the configuration data at this Revision.
	ApplyGates map[string]bool `json:"ApplyGates,omitempty"`

	// ApprovedBy the users that have approved the latest version of the config data for the Unit.
	ApprovedBy []UUID `json:"ApprovedBy"`

	// ContentHash The CRC32 hash of this revision's data.
	ContentHash int `json:"ContentHash,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// Data The full configuration data for this unit at this revision.
	Data string `json:"Data,omitempty"`

	// Description User description of the change. It is copied from the LastChangeDescription field of the Unit at the time the change was made that created the Revision.
	Description string `json:"Description,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// LiveAt Time at which the revision was applied, if it was applied. If not applied, the value is "0001-01-01T00:00:00Z".
	LiveAt          time.Time             `json:"LiveAt,omitempty"`
	MutationSources *ResourceMutationList `json:"MutationSources"`

	// OrganizationID Unique identifier for an Organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// RevisionID Unique identifier for a Revision.
	RevisionID openapi_types.UUID `json:"RevisionID,omitempty"`

	// RevisionNum Sequence number for a Revision.
	RevisionNum int64 `json:"RevisionNum,omitempty"`

	// Source ConfigHub operation that created this revision.
	Source string `json:"Source,omitempty"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UnitID Unique identifier for a Unit.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// UserAgent User-Agent string if created by an API call. Optional.
	UserAgent string `json:"UserAgent,omitempty"`

	// UserID UserID if change was made by a user. Automated changes, such as by triggers and resolve, are currently made with the UserID "00000000-0000-0000-0000-000000000000".
	UserID openapi_types.UUID `json:"UserID,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// RevisionExtended defines model for RevisionExtended.
type RevisionExtended struct {
	ApprovedByUsers []string `json:"ApprovedByUsers"`

	// Revision Revision is a historial view of a Config Unit.
	Revision *Revision `json:"Revision,omitempty"`
	Username string    `json:"Username,omitempty"`
}

// Set A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
type Set struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// SetID Unique identifier for a Set.
	SetID openapi_types.UUID `json:"SetID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// SetExtended defines model for SetExtended.
type SetExtended struct {
	// Set A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
	Set *Set `json:"Set,omitempty"`
}

// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
type Space struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// SpaceExtended defines model for SpaceExtended.
type SpaceExtended struct {
	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`
}

// StandardErrorResponse Error response details.
type StandardErrorResponse struct {
	// Code HTTP status code of the response.
	Code string `json:"Code,omitempty"`

	// Message Message returned with the response.
	Message string `json:"Message,omitempty"`
}

// Target Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
type Target struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// BridgeWorkerID Unique identifier for a Bridge Worker associated with the Target.
	BridgeWorkerID openapi_types.UUID `json:"BridgeWorkerID,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Parameters Parameters contains toolchain-type and/or provider-type-specific parameters in JSON format.
	//
	// For ProviderType: Kubernetes (ToolchainType: Kubernetes/YAML)
	// The Parameters object may contain the following fields:
	// - "KubeContext" (string): The name of the Kubernetes context (from "~/.kube/config") to use. (Not typically needed if running in-cluster).
	// - "KubeNamespace" (string, optional): The target Kubernetes namespace for applying or managing resources.
	// - "WaitTimeout" (string): A duration string (e.g., "5m", "2m30s") specifying how long to wait for resources to reach a ready state. Defaults to "2m0s".
	//
	// For ProviderType: FluxOCIWriter (ToolchainType: Kubernetes/YAML)
	// The Parameters object may contain the following fields:
	// - "Repository" (string, required): The base OCI repository URL (e.g., "oci://ghcr.io/my-org"). The 'UnitSlug' (a system-provided identifier for the configuration unit) will be appended to this URL to form the full image path (e.g., "oci://ghcr.io/my-org/<UnitSlug>").
	// - "Tag" (string, optional): Explicit OCI tag for the image. Confighub will automatically set the tag on each push using the Unit's current RevisionNum being applied. This will have 'rev' prefixed to the number, like 'rev42'. When Tag is populated, it can be used to explicitly set a value that you want Confighub to publish to the OCI in addition to the default RevisionNum tag. For example 'latest' or 'trunk'.
	// - "Provider" (string, optional): Specifies the authentication provider for the OCI registry. Defaults to "None".
	//     Possible values:
	//     - "None": Uses local Docker configuration (e.g., from '~/.docker/config.json') or the system's credential keychain.
	//     - "Generic": Uses generic OCI provider authentication.
	//     - "AWS": Uses AWS ECR authentication.
	//     - "Azure": Uses Azure CR authentication.
	//     - "GCP": Uses Google CR/Artifact Registry authentication.
	// - "AllowDeletion" (string, optional): A boolean string ("true" or "false") indicating if the worker is allowed to delete images from the repository. Defaults to "false".
	// - "KubernetesSecretName" (string, optional): The name of a Kubernetes Secret containing Docker credentials. The secret should typically have a '.dockerconfigjson' key, or 'username' and 'password' keys.
	// - "KubernetesSecretNamespace" (string, optional): The Kubernetes namespace where the "KubernetesSecretName" is located. If not specified, the secret is assumed to be in the same namespace as the ConfigHub worker.
	Parameters string `json:"Parameters,omitempty"`

	// ProviderType ProviderType specifies the cloud or infrastructure provider for this target, such as "Kubernetes" or "AWS".
	ProviderType string `json:"ProviderType,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// TargetID Unique identifier for a Target.
	TargetID openapi_types.UUID `json:"TargetID,omitempty"`

	// ToolchainType ToolchainType specifies the type of toolchain supported by this Target. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
	ToolchainType string `json:"ToolchainType,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// TargetExtended defines model for TargetExtended.
type TargetExtended struct {
	// Target Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
	Target *Target `json:"Target,omitempty"`
}

// TargetType2 defines model for TargetType2.
type TargetType2 struct {
	// Name Used to set the Slug and DisplayName of the Target created in ConfigHub
	Name string `json:"Name,omitempty"`

	// Params Used to set the Parameters of the Target created in ConfigHub
	Params map[string]interface{} `json:"Params,omitempty"`
}

// Trigger Defines an automated function invocation that executes in response to specific
// Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
// automated transformations, or other custom logic that should run when configuration
// changes occur. Each Trigger is associated with a specific Space and can be configured
// to execute on events.
//
// Triggers can be either validating (checking configuration validity without modifying it)
// or mutating (making changes to the configuration). They can also be enforced (cannot be
// overridden) or disabled.
type Trigger struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// Arguments Function arguments
	Arguments      []FunctionArgument `json:"Arguments"`
	BridgeWorkerID *UUID              `json:"BridgeWorkerID,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// Disabled Disabled indicates whether this trigger is currently disabled.
	// 		When disabled, the trigger will not be executed even when matching events occur.
	Disabled bool `json:"Disabled,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// Enforced Enforced indicates whether this trigger cannot be overridden.
	// 		Enforced triggers implement mandatory policies that cannot be bypassed.
	Enforced bool `json:"Enforced,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Event Event specifies the type of event that will activate this trigger. Valid values are Mutation, PreClone, and PostClone
	Event string `json:"Event,omitempty"`

	// FunctionName Function name
	FunctionName string `json:"FunctionName,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// ToolchainType ToolchainType specifies the type of toolchain this trigger works with.
	// 		This determines which configuration formats the trigger can process.
	ToolchainType string `json:"ToolchainType,omitempty"`

	// TriggerID TriggerID uniquely identifies a trigger within the system.
	TriggerID openapi_types.UUID `json:"TriggerID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Validating Validating indicates whether this is a validating function (true) or mutating function (false).
	// 		Validating functions check configuration validity without modifying it. Mutating functions can make changes to the configuration.
	// 		This value is returned by ConfigHub based on the corresponding property of the specified function.
	Validating bool `json:"Validating,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// TriggerExtended defines model for TriggerExtended.
type TriggerExtended struct {
	// Trigger Defines an automated function invocation that executes in response to specific
	// Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
	// automated transformations, or other custom logic that should run when configuration
	// changes occur. Each Trigger is associated with a specific Space and can be configured
	// to execute on events.
	//
	// Triggers can be either validating (checking configuration validity without modifying it)
	// or mutating (making changes to the configuration). They can also be enforced (cannot be
	// overridden) or disabled.
	Trigger *Trigger `json:"Trigger,omitempty"`
}

// UUID defines model for UUID.
type UUID = openapi_types.UUID

// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
// file. Applying / deploying or destroying the configuration happens as a single "transaction"
// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
// the underlying configuration / deployment tool. The resources must belong to a single
// infrastructure provider and the actuation mechanism must be able to resolve references and
// ordering dependencies among the resources within the document. For example, if one resource
// needs to be fully provisioned to provide input to another resource, then the actuation code is
// responsible for handling this. Revisions store historical copies of the configuration data.
// Configuration data can be restored from prior Revisions. Units can also be cloned to create
// new variants of a configuration.
type Unit struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// ApplyGates A map of "<trigger slug>/<function name>" to true of Triggers invoking validating functions that did not pass on the latest configuration data.
	ApplyGates map[string]bool `json:"ApplyGates,omitempty"`

	// ApprovedBy The users that have approved the latest revision of the config data for the Unit.
	ApprovedBy []UUID `json:"ApprovedBy"`

	// ContentHash The CRC32 hash of the configuration data.
	ContentHash int `json:"ContentHash,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// Data The full configuration data for this unit.
	Data string `json:"Data,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// HeadMutationNum Sequence number the head Mutation.
	HeadMutationNum int64 `json:"HeadMutationNum,omitempty"`

	// HeadRevisionNum Sequence number the head Revision.
	HeadRevisionNum int64 `json:"HeadRevisionNum,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// LastAppliedRevisionNum Sequence number the last Revision applied. 0 if no live revision.
	LastAppliedRevisionNum int64 `json:"LastAppliedRevisionNum,omitempty"`

	// LastChangeDescription LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.
	LastChangeDescription string `json:"LastChangeDescription,omitempty"`

	// LiveRevisionNum Sequence number the last Revision applied once apply has completed. 0 if no live revision.
	LiveRevisionNum int64 `json:"LiveRevisionNum,omitempty"`

	// LiveState The current live state of the Unit as reported by the bridge worker associated with the Target attached to the Unit.
	LiveState       string                `json:"LiveState,omitempty"`
	MutationSources *ResourceMutationList `json:"MutationSources"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Outputs The outputs of the last successful apply of the Unit.
	Outputs string `json:"Outputs,omitempty"`

	// PreviousLiveRevisionNum Sequence number the previous Revision applied. 0 if no live revision.
	PreviousLiveRevisionNum int64 `json:"PreviousLiveRevisionNum,omitempty"`
	SetID                   *UUID `json:"SetID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID  openapi_types.UUID `json:"SpaceID,omitempty"`
	TargetID *UUID              `json:"TargetID,omitempty"`

	// ToolchainType ToolchainType specifies the type of toolchain for this unit. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
	ToolchainType string `json:"ToolchainType,omitempty"`

	// UnitID Unique identifier for a Unit.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt              time.Time `json:"UpdatedAt,omitempty"`
	UpstreamOrganizationID *UUID     `json:"UpstreamOrganizationID,omitempty"`

	// UpstreamRevisionNum Sequence number for the Revision of the Unit this unit was cloned from, or 0. This is updated to the upstream Unit's head revision number when the Unit is upgraded.
	UpstreamRevisionNum int64 `json:"UpstreamRevisionNum,omitempty"`
	UpstreamSpaceID     *UUID `json:"UpstreamSpaceID,omitempty"`
	UpstreamUnitID      *UUID `json:"UpstreamUnitID,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// UnitEvent UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks
// the lifecycle of applying, destroying, or refreshing a Unit's configuration in the target
// live system. The event captures the current status of the operation, any configuration
// drift detected, and timing information about when the action started and completed.
// Actions are atomic from ConfigHub's perspective but may involve multiple steps
// in the connected Bridge. The status and drift detection help track the health
// and consistency of the provisioned configuration compared to what is defined in the Unit.
type UnitEvent struct {
	Action *ActionType `json:"Action,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`
	Message    string `json:"Message,omitempty"`

	// OrganizationID Unique identifier for an Organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// QueuedOperationID QueuedOperationID is the unique identifier for the corresponding queued operation.
	QueuedOperationID openapi_types.UUID `json:"QueuedOperationID,omitempty"`
	Result            *ActionResultType  `json:"Result,omitempty"`
	RevisionNum       int64              `json:"RevisionNum,omitempty"`

	// SpaceID Unique identifier for a space.
	SpaceID      openapi_types.UUID `json:"SpaceID,omitempty"`
	StartedAt    time.Time          `json:"StartedAt,omitempty"`
	Status       *ActionStatusType  `json:"Status,omitempty"`
	TerminatedAt time.Time          `json:"TerminatedAt"`
	UnitEventID  openapi_types.UUID `json:"UnitEventID,omitempty"`

	// UnitID Unique identifier for a Unit.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// UnitExtended defines model for UnitExtended.
type UnitExtended struct {
	Action             *ActionType       `json:"Action,omitempty"`
	ActionResult       *ActionResultType `json:"ActionResult,omitempty"`
	ActionStartedAt    time.Time         `json:"ActionStartedAt"`
	ActionTerminatedAt time.Time         `json:"ActionTerminatedAt"`
	ApprovedByUsers    []string          `json:"ApprovedByUsers"`
	Drift              string            `json:"Drift,omitempty"`
	FromLinks          []Link            `json:"FromLinks"`
	Status             string            `json:"Status,omitempty"`
	ToLinks            []Link            `json:"ToLinks"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single "transaction"
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit *Unit `json:"Unit,omitempty"`
}

// UnitStatus defines model for UnitStatus.
type UnitStatus struct {
	Action             *ActionType       `json:"Action,omitempty"`
	ActionResult       *ActionResultType `json:"ActionResult,omitempty"`
	ActionStartedAt    time.Time         `json:"ActionStartedAt"`
	ActionTerminatedAt time.Time         `json:"ActionTerminatedAt"`
	Drift              string            `json:"Drift,omitempty"`
	Status             string            `json:"Status,omitempty"`
}

// UpgradeUnitResponse defines model for UpgradeUnitResponse.
type UpgradeUnitResponse struct {
	FailedUnits   map[string]string `json:"FailedUnits"`
	UpgradedUnits []Unit            `json:"UpgradedUnits"`
}

// User a User in Confighub.
type User struct {
	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// ExternalID Unique identifier for the External Identity Provider record matching this User.
	ExternalID string `json:"ExternalID,omitempty"`

	// ProfilePictureURL The URL to get the profile avatar picture of the User.
	ProfilePictureURL string `json:"ProfilePictureURL,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// UserID Unique identifier for a User.
	UserID openapi_types.UUID `json:"UserID,omitempty"`

	// Username Unique username for a User. Must be unique for all of Confighub.
	Username string `json:"Username,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// WorkerInfo defines model for WorkerInfo.
type WorkerInfo struct {
	BridgeWorkerInfo   *BridgeWorkerInfo   `json:"BridgeWorkerInfo,omitempty"`
	FunctionWorkerInfo *FunctionWorkerInfo `json:"FunctionWorkerInfo,omitempty"`
}

// ListAllBridgeWorkersParams defines parameters for ListAllBridgeWorkers.
type ListAllBridgeWorkersParams struct {
	// Include Include clause for expanding related entities in the response for bridge_worker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for bridge_worker are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on bridge_worker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Summary Include summary information in the response
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// InvokeFunctionsOnOrgParams defines parameters for InvokeFunctionsOnOrg.
type InvokeFunctionsOnOrgParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`
}

// ListOrganizationsParams defines parameters for ListOrganizations.
type ListOrganizationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Organization: BillingAccountID, CreatedAt, DisplayName, ExternalID, Labels, OrganizationID, Slug, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Organization.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Organization are .
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// GetOrganizationParams defines parameters for GetOrganization.
type GetOrganizationParams struct {
	// Include Include clause for expanding related entities in the response for Organization.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Organization are .
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListOrganizationMembersParams defines parameters for ListOrganizationMembers.
type ListOrganizationMembersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on OrganizationMember: DisplayName, ExternalID, Slug, UserID, Username.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`
}

// ListSpacesParams defines parameters for ListSpaces.
type ListSpacesParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Space are OrganizationID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Summary Flag parameter for enabling summary
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// GetSpaceParams defines parameters for GetSpace.
type GetSpaceParams struct {
	// Include Include clause for expanding related entities in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Space are OrganizationID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Summary Flag parameter for enabling summary
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// ListBridgeWorkersParams defines parameters for ListBridgeWorkers.
type ListBridgeWorkersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for BridgeWorker are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// GetBridgeWorkerParams defines parameters for GetBridgeWorker.
type GetBridgeWorkerParams struct {
	// Include Include clause for expanding related entities in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for BridgeWorker are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListFunctionsParams defines parameters for ListFunctions.
type ListFunctionsParams struct {
	// Entity Type of entity used to identify the worker whose functions should be listed: unit, target, or worker
	Entity *string `form:"entity,omitempty" json:"entity,omitempty"`

	// Id ID of the entity used to identify the worker whose functions should be listed
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// InvokeFunctionsParams defines parameters for InvokeFunctions.
type InvokeFunctionsParams struct {
	// UnitId Unit ID of the Revision to invoke functions on
	UnitId *openapi_types.UUID `form:"unit_id,omitempty" json:"unit_id,omitempty"`

	// RevisionId Revision ID to invoke functions on instead of units
	RevisionId *openapi_types.UUID `form:"revision_id,omitempty" json:"revision_id,omitempty"`

	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`
}

// ListLinksParams defines parameters for ListLinks.
type ListLinksParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Link: CreatedAt, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// GetLinkParams defines parameters for GetLink.
type GetLinkParams struct {
	// Include Include clause for expanding related entities in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListSetsParams defines parameters for ListSets.
type ListSetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Set: CreatedAt, DisplayName, Labels, OrganizationID, SetID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Set.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Set are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// GetSetParams defines parameters for GetSet.
type GetSetParams struct {
	// Include Include clause for expanding related entities in the response for Set.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Set are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListTargetsParams defines parameters for ListTargets.
type ListTargetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// GetTargetParams defines parameters for GetTarget.
type GetTargetParams struct {
	// Include Include clause for expanding related entities in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListTriggersParams defines parameters for ListTriggers.
type ListTriggersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, Disabled, DisplayName, Enforced, Event, FunctionName, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Trigger are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// GetTriggerParams defines parameters for GetTrigger.
type GetTriggerParams struct {
	// Include Include clause for expanding related entities in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Trigger are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListUnitsParams defines parameters for ListUnits.
type ListUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// CreateUnitParams defines parameters for CreateUnit.
type CreateUnitParams struct {
	// UpstreamSpaceId Unique identifier for a upstream_space_id
	UpstreamSpaceId *openapi_types.UUID `form:"upstream_space_id,omitempty" json:"upstream_space_id,omitempty"`

	// UpstreamUnitId Unique identifier for a upstream_unit_id
	UpstreamUnitId *openapi_types.UUID `form:"upstream_unit_id,omitempty" json:"upstream_unit_id,omitempty"`
}

// ListExtendedUnitsParams defines parameters for ListExtendedUnits.
type ListExtendedUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateUnitParams defines parameters for UpdateUnit.
type UpdateUnitParams struct {
	// RevisionId Unique identifier for a revision_id
	RevisionId *openapi_types.UUID `form:"revision_id,omitempty" json:"revision_id,omitempty"`

	// Upgrade Flag parameter for enabling upgrade
	Upgrade *bool `form:"upgrade,omitempty" json:"upgrade,omitempty"`
}

// ListExtendedMutationsParams defines parameters for ListExtendedMutations.
type ListExtendedMutationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Mutation: CreatedAt, FunctionName, LinkID, MutationID, MutationNum, OrganizationID, RevisionID, RevisionNum, SpaceID, TriggerID, UnitID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Mutation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Mutation are LinkID, OrganizationID, RevisionID, SpaceID, TriggerID, UnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// GetExtendedMutationParams defines parameters for GetExtendedMutation.
type GetExtendedMutationParams struct {
	// Include Include clause for expanding related entities in the response for Mutation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Mutation are LinkID, OrganizationID, RevisionID, SpaceID, TriggerID, UnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListExtendedRevisionsParams defines parameters for ListExtendedRevisions.
type ListExtendedRevisionsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Revision: ApplyGates, ApprovedBy, CreatedAt, Description, LiveAt, OrganizationID, RevisionID, RevisionNum, Source, SpaceID, UnitID, UpdatedAt, UserAgent, UserID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Revision.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Revision are OrganizationID, SpaceID, UnitID, UserID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// GetExtendedRevisionParams defines parameters for GetExtendedRevision.
type GetExtendedRevisionParams struct {
	// Include Include clause for expanding related entities in the response for Revision.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Revision are OrganizationID, SpaceID, UnitID, UserID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListUnitEventsParams defines parameters for ListUnitEvents.
type ListUnitEventsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on UnitEvent: Action, CreatedAt, OrganizationID, QueuedOperationID, Result, RevisionNum, SpaceID, StartedAt, Status, TerminatedAt, UnitEventID, UnitID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`
}

// ListAllTargetsParams defines parameters for ListAllTargets.
type ListAllTargetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllUnitsParams defines parameters for ListAllUnits.
type ListAllUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// ResourceType Resource type: Resource type to match for the desired ToolchainType, for example apps/v1/Deployment
	ResourceType *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`

	// WhereData Where data filter: The specified string is an expression for the purpose of evaluating whether the configuration data matches the filter. The expression syntax was inspired by SQL. It supports conjunctions using `AND` of relational expressions of the form *path* *operator* *literal*. The path specifications are dot-separated, for both map fields and array indices, as in `spec.template.spec.containers.0.image = 'ghcr.io/headlamp-k8s/headlamp:latest' AND spec.replicas > 1`. Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`. Boolean values support equality and inequality only. String literals are quoted with single quotes, such as `'string'`. Integer and boolean literals are also supported for attributes of those types. The whole string must be query-encoded.
	WhereData *string `form:"where_data,omitempty" json:"where_data,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on User: CreatedAt, DisplayName, ExternalID, Slug, UpdatedAt, UserID, Username.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`
}

// CreateActionResultJSONRequestBody defines body for CreateActionResult for application/json ContentType.
type CreateActionResultJSONRequestBody = ActionResult

// InvokeFunctionsOnOrgJSONRequestBody defines body for InvokeFunctionsOnOrg for application/json ContentType.
type InvokeFunctionsOnOrgJSONRequestBody = FunctionInvocationsRequest

// CreateOrganizationJSONRequestBody defines body for CreateOrganization for application/json ContentType.
type CreateOrganizationJSONRequestBody = Organization

// UpdateOrganizationJSONRequestBody defines body for UpdateOrganization for application/json ContentType.
type UpdateOrganizationJSONRequestBody = Organization

// CreateOrganizationMemberJSONRequestBody defines body for CreateOrganizationMember for application/json ContentType.
type CreateOrganizationMemberJSONRequestBody = OrganizationMember

// CreateSpaceJSONRequestBody defines body for CreateSpace for application/json ContentType.
type CreateSpaceJSONRequestBody = Space

// UpdateSpaceJSONRequestBody defines body for UpdateSpace for application/json ContentType.
type UpdateSpaceJSONRequestBody = Space

// CreateBridgeWorkerJSONRequestBody defines body for CreateBridgeWorker for application/json ContentType.
type CreateBridgeWorkerJSONRequestBody = BridgeWorker

// UpdateBridgeWorkerJSONRequestBody defines body for UpdateBridgeWorker for application/json ContentType.
type UpdateBridgeWorkerJSONRequestBody = BridgeWorker

// InvokeFunctionsJSONRequestBody defines body for InvokeFunctions for application/json ContentType.
type InvokeFunctionsJSONRequestBody = FunctionInvocationsRequest

// CreateLinkJSONRequestBody defines body for CreateLink for application/json ContentType.
type CreateLinkJSONRequestBody = Link

// UpdateLinkJSONRequestBody defines body for UpdateLink for application/json ContentType.
type UpdateLinkJSONRequestBody = Link

// CreateSetJSONRequestBody defines body for CreateSet for application/json ContentType.
type CreateSetJSONRequestBody = Set

// UpdateSetJSONRequestBody defines body for UpdateSet for application/json ContentType.
type UpdateSetJSONRequestBody = Set

// CreateTargetJSONRequestBody defines body for CreateTarget for application/json ContentType.
type CreateTargetJSONRequestBody = Target

// UpdateTargetJSONRequestBody defines body for UpdateTarget for application/json ContentType.
type UpdateTargetJSONRequestBody = Target

// CreateTriggerJSONRequestBody defines body for CreateTrigger for application/json ContentType.
type CreateTriggerJSONRequestBody = Trigger

// UpdateTriggerJSONRequestBody defines body for UpdateTrigger for application/json ContentType.
type UpdateTriggerJSONRequestBody = Trigger

// CreateUnitJSONRequestBody defines body for CreateUnit for application/json ContentType.
type CreateUnitJSONRequestBody = Unit

// UpdateUnitJSONRequestBody defines body for UpdateUnit for application/json ContentType.
type UpdateUnitJSONRequestBody = Unit

// ImportUnitJSONRequestBody defines body for ImportUnit for application/json ContentType.
type ImportUnitJSONRequestBody = ImportRequest

// AsFunctionArgumentValue0 returns the union data inside the FunctionArgument_Value as a FunctionArgumentValue0
func (t FunctionArgument_Value) AsFunctionArgumentValue0() (FunctionArgumentValue0, error) {
	var body FunctionArgumentValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionArgumentValue0 overwrites any union data inside the FunctionArgument_Value as the provided FunctionArgumentValue0
func (t *FunctionArgument_Value) FromFunctionArgumentValue0(v FunctionArgumentValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionArgumentValue0 performs a merge with any union data inside the FunctionArgument_Value, using the provided FunctionArgumentValue0
func (t *FunctionArgument_Value) MergeFunctionArgumentValue0(v FunctionArgumentValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionArgumentValue1 returns the union data inside the FunctionArgument_Value as a FunctionArgumentValue1
func (t FunctionArgument_Value) AsFunctionArgumentValue1() (FunctionArgumentValue1, error) {
	var body FunctionArgumentValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionArgumentValue1 overwrites any union data inside the FunctionArgument_Value as the provided FunctionArgumentValue1
func (t *FunctionArgument_Value) FromFunctionArgumentValue1(v FunctionArgumentValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionArgumentValue1 performs a merge with any union data inside the FunctionArgument_Value, using the provided FunctionArgumentValue1
func (t *FunctionArgument_Value) MergeFunctionArgumentValue1(v FunctionArgumentValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionArgumentValue2 returns the union data inside the FunctionArgument_Value as a FunctionArgumentValue2
func (t FunctionArgument_Value) AsFunctionArgumentValue2() (FunctionArgumentValue2, error) {
	var body FunctionArgumentValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionArgumentValue2 overwrites any union data inside the FunctionArgument_Value as the provided FunctionArgumentValue2
func (t *FunctionArgument_Value) FromFunctionArgumentValue2(v FunctionArgumentValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionArgumentValue2 performs a merge with any union data inside the FunctionArgument_Value, using the provided FunctionArgumentValue2
func (t *FunctionArgument_Value) MergeFunctionArgumentValue2(v FunctionArgumentValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FunctionArgument_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FunctionArgument_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
