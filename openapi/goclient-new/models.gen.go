// Copyright (C) ConfigHub, Inc.
// SPDX-License-Identifier: MIT

// Package goclientnew provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package goclientnew

import (
	"encoding/json"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ActionResultType.
const (
	ActionResultTypeApplyCompleted    ActionResultType = "ApplyCompleted"
	ActionResultTypeApplyFailed       ActionResultType = "ApplyFailed"
	ActionResultTypeApplyWaitFailed   ActionResultType = "ApplyWaitFailed"
	ActionResultTypeDestroyCompleted  ActionResultType = "DestroyCompleted"
	ActionResultTypeDestroyFailed     ActionResultType = "DestroyFailed"
	ActionResultTypeDestroyWaitFailed ActionResultType = "DestroyWaitFailed"
	ActionResultTypeImportCompleted   ActionResultType = "ImportCompleted"
	ActionResultTypeImportFailed      ActionResultType = "ImportFailed"
	ActionResultTypeNone              ActionResultType = "None"
	ActionResultTypeRefreshAndDrifted ActionResultType = "RefreshAndDrifted"
	ActionResultTypeRefreshAndNoDrift ActionResultType = "RefreshAndNoDrift"
	ActionResultTypeRefreshFailed     ActionResultType = "RefreshFailed"
)

// Defines values for ActionStatusType.
const (
	ActionStatusTypeCanceled    ActionStatusType = "Canceled"
	ActionStatusTypeCompleted   ActionStatusType = "Completed"
	ActionStatusTypeFailed      ActionStatusType = "Failed"
	ActionStatusTypeNone        ActionStatusType = "None"
	ActionStatusTypePending     ActionStatusType = "Pending"
	ActionStatusTypeProgressing ActionStatusType = "Progressing"
	ActionStatusTypeSubmitted   ActionStatusType = "Submitted"
)

// Defines values for ActionType.
const (
	Apply     ActionType = "Apply"
	Destroy   ActionType = "Destroy"
	Finalize  ActionType = "Finalize"
	Heartbeat ActionType = "Heartbeat"
	Import    ActionType = "Import"
	NA        ActionType = "N/A"
	Refresh   ActionType = "Refresh"
)

// Defines values for MutationType.
const (
	Add     MutationType = "Add"
	Delete  MutationType = "Delete"
	None    MutationType = "None"
	Replace MutationType = "Replace"
	Update  MutationType = "Update"
)

// ActionResult defines model for ActionResult.
type ActionResult struct {
	Action *ActionType `json:"Action,omitempty"`

	// Data Configuration data of the Unit
	Data string `json:"Data,omitempty"`

	// LiveState Live state corresponding to the Unit
	LiveState string `json:"LiveState,omitempty"`
	Message   string `json:"Message,omitempty"`

	// Outputs Outputs resulting from applying the configuration data of the Unit
	Outputs string `json:"Outputs,omitempty"`

	// QueuedOperationID UUID of the operation corresponding to the action request
	QueuedOperationID openapi_types.UUID `json:"QueuedOperationID,omitempty"`
	Result            *ActionResultType  `json:"Result,omitempty"`
	RevisionNum       int64              `json:"RevisionNum,omitempty"`

	// SpaceID UUID of the Space of the Unit on which the action is performed
	SpaceID      openapi_types.UUID `json:"SpaceID,omitempty"`
	StartedAt    time.Time          `json:"StartedAt,omitempty"`
	Status       *ActionStatusType  `json:"Status,omitempty"`
	TerminatedAt time.Time          `json:"TerminatedAt"`

	// UnitID UUID of the Unit on which the action is performed
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`
}

// ActionResultType defines model for ActionResultType.
type ActionResultType string

// ActionStatusType defines model for ActionStatusType.
type ActionStatusType string

// ActionType defines model for ActionType.
type ActionType string

// ApiInfo Information provided to clients by the server.
type ApiInfo struct {
	AuthServer string `json:"AuthServer,omitempty"`

	// Build Build identifier for support cases.
	Build string `json:"Build,omitempty"`

	// BuiltAt The timestamp when ConfigHub was built in "2023-01-01T12:00:00Z" format for support cases.
	BuiltAt string `json:"BuiltAt,omitempty"`

	// ClientID ClientID for identity provider service.
	ClientID    string `json:"ClientID,omitempty"`
	RedirectURI string `json:"RedirectURI,omitempty"`

	// Revision Service revision identifier for support cases.
	Revision string `json:"Revision,omitempty"`

	// WorkerPort Port number for the worker to connect to the server.
	WorkerPort string `json:"WorkerPort,omitempty"`
}

// ApproveResponse defines model for ApproveResponse.
type ApproveResponse struct {
	Error   *ResponseError `json:"Error,omitempty"`
	Message string         `json:"Message,omitempty"`
}

// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
// It acts as a bridge between ConfigHub and the infrastructure where configurations need
// to be applied. Bridge workers are responsible for executing configuration changes on
// remote targets and reporting status back to ConfigHub.
// When starting a bridge worker program, both the BridgeWorkerID and Secret are
// required for authentication with the ConfigHub server. These credentials allow the
// bridge worker to establish a secure connection and receive configuration actions.
type BridgeWorker struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// BridgeWorkerID Unique identifier for a Bridge Worker.
	BridgeWorkerID openapi_types.UUID `json:"BridgeWorkerID,omitempty"`

	// Condition Condition represents the worker's readiness state (Ready, NotReady, Unresponsive, Disconnected).
	Condition string `json:"Condition,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// IPAddress IPAddress is the IP address from which the worker last connected.
	IPAddress string `json:"IPAddress,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// LastMessage LastMessage contains the last message from the worker (heartbeat message or other status).
	LastMessage string `json:"LastMessage,omitempty"`

	// LastSeenAt LastSeenAt is the time the worker was last seen (heartbeat, connection, or any event).
	LastSeenAt time.Time `json:"LastSeenAt,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`
	ProvidedInfo   *WorkerInfo        `json:"ProvidedInfo,omitempty"`

	// Secret Secret is a unique secret token for the bridge worker.
	// It's auto-generated when the BridgeWorker entity is created and cannot be modified.
	// This field is output-only and used for authentication.
	// This secret is required when starting the bridge worker program.
	Secret string `json:"Secret,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`
	UserID    *UUID     `json:"UserID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// BridgeWorkerCreateOrUpdateResponse defines model for BridgeWorkerCreateOrUpdateResponse.
type BridgeWorkerCreateOrUpdateResponse struct {
	// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
	// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
	// It acts as a bridge between ConfigHub and the infrastructure where configurations need
	// to be applied. Bridge workers are responsible for executing configuration changes on
	// remote targets and reporting status back to ConfigHub.
	// When starting a bridge worker program, both the BridgeWorkerID and Secret are
	// required for authentication with the ConfigHub server. These credentials allow the
	// bridge worker to establish a secure connection and receive configuration actions.
	BridgeWorker *BridgeWorker  `json:"BridgeWorker,omitempty"`
	Error        *ResponseError `json:"Error,omitempty"`
}

// BridgeWorkerInfo defines model for BridgeWorkerInfo.
type BridgeWorkerInfo struct {
	// SupportedConfigTypes Configuration types supported by the BridgeWorker
	SupportedConfigTypes []ConfigType `json:"SupportedConfigTypes,omitempty"`
}

// BridgeWorkerStatus BridgeWorkerStatus represents the status information of a bridge worker within the system.
type BridgeWorkerStatus struct {
	// BridgeWorkerID Unique identifier for the Bridge Worker.
	BridgeWorkerID openapi_types.UUID `json:"BridgeWorkerID,omitempty"`

	// BridgeWorkerSlug Slug for the Bridge Worker.
	BridgeWorkerSlug string `json:"BridgeWorkerSlug,omitempty"`

	// BridgeWorkerStatusID BridgeWorkerStatusID is the unique identifier for the bridge worker status entry.
	BridgeWorkerStatusID openapi_types.UUID `json:"BridgeWorkerStatusID,omitempty"`

	// IPAddress IPAddress is the IP address from which the bridge worker is connecting.
	IPAddress string `json:"IPAddress,omitempty"`

	// OrganizationID OrganizationID is the unique identifier of the organization the bridge worker belongs to.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// SeenAt The timestamp when the bridge worker last responded in "2023-01-01T12:00:00Z" format.
	SeenAt time.Time `json:"SeenAt,omitempty"`

	// SpaceID SpaceID is the unique identifier of the space the bridge worker belongs to.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// Status Status indicates the current status of the bridge worker. Possible values include Connected, Disconnected, ActionSent, ActionResultReceived.
	Status string `json:"Status,omitempty"`
}

// ChangeSet Defines an entity changeset.
type ChangeSet struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// ChangeSetID ChangeSetID uniquely identifies a changeset within the system.
	ChangeSetID openapi_types.UUID `json:"ChangeSetID,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// Description Description is a human-readable description of the change.
	Description string `json:"Description,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`
	EndTagID    *UUID  `json:"EndTagID"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`
	FilterID   *UUID  `json:"FilterID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID    openapi_types.UUID `json:"SpaceID,omitempty"`
	StartTagID *UUID              `json:"StartTagID"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// ChangeSetCreateOrUpdateResponse defines model for ChangeSetCreateOrUpdateResponse.
type ChangeSetCreateOrUpdateResponse struct {
	// ChangeSet Defines an entity changeset.
	ChangeSet *ChangeSet     `json:"ChangeSet,omitempty"`
	Error     *ResponseError `json:"Error,omitempty"`
}

// Column defines model for Column.
type Column struct {
	// Name Name of the column in PascalCase without spaces or dashes, if built-in, entity attribute (e.g., Labels.Environment), or extended attribute (e.g., UpstreamUnit.HeadRevisionNum)
	Name string `json:"Name"`
}

// ConfigType defines model for ConfigType.
type ConfigType struct {
	// AvailableTargets Targets known by the BridgeWorker
	AvailableTargets []TargetType2 `json:"AvailableTargets,omitempty"`

	// ProviderType Provider subtype of the configuration toolchain supported by the BridgegWorker
	ProviderType string `json:"ProviderType,omitempty"`

	// ToolchainType Configuration toolchain and format supported by the BridgeWorker
	ToolchainType string `json:"ToolchainType,omitempty"`
}

// DeleteResponse Response for successful delete operation
type DeleteResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Message Response message.
	Message string `json:"Message,omitempty"`
}

// ErrorItem defines model for ErrorItem.
type ErrorItem struct {
	// Description A clear explanation of what went wrong
	Description string `json:"Description,omitempty"`

	// Item The name of the field, resource, or entity that the error relates to
	Item string `json:"Item,omitempty"`
}

// ErrorMetadata defines model for ErrorMetadata.
type ErrorMetadata struct {
	// EntityID Optional ID of the entity this error relates to
	EntityID string `json:"EntityID,omitempty"`

	// EntityType Optional type of the entity this error relates to
	EntityType string `json:"EntityType,omitempty"`

	// Items Collection of error details
	Items []ErrorItem `json:"Items,omitempty"`
}

// EventMessage defines model for EventMessage.
type EventMessage struct {
	Data  *string `json:"Data,omitempty"`
	Event *string `json:"Event,omitempty"`
}

// ExtendedBridgeWorker defines model for ExtendedBridgeWorker.
type ExtendedBridgeWorker struct {
	// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
	// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
	// It acts as a bridge between ConfigHub and the infrastructure where configurations need
	// to be applied. Bridge workers are responsible for executing configuration changes on
	// remote targets and reporting status back to ConfigHub.
	// When starting a bridge worker program, both the BridgeWorkerID and Secret are
	// required for authentication with the ConfigHub server. These credentials allow the
	// bridge worker to establish a secure connection and receive configuration actions.
	BridgeWorker *BridgeWorker  `json:"BridgeWorker,omitempty"`
	Error        *ResponseError `json:"Error,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space       *Space `json:"Space,omitempty"`
	TargetCount int64  `json:"TargetCount,omitempty"`
}

// ExtendedChangeSet defines model for ExtendedChangeSet.
type ExtendedChangeSet struct {
	// ChangeSet Defines an entity changeset.
	ChangeSet *ChangeSet `json:"ChangeSet,omitempty"`

	// EndTag Defines a Tag that can be used to identify a set of Revisions across Units.
	EndTag *Tag           `json:"EndTag,omitempty"`
	Error  *ResponseError `json:"Error,omitempty"`

	// Filter Defines an entity filter.
	Filter *Filter `json:"Filter,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// StartTag Defines a Tag that can be used to identify a set of Revisions across Units.
	StartTag *Tag `json:"StartTag,omitempty"`
}

// ExtendedFilter defines model for ExtendedFilter.
type ExtendedFilter struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Filter Defines an entity filter.
	Filter *Filter `json:"Filter,omitempty"`

	// FromSpace The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	FromSpace *Space `json:"FromSpace,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`
}

// ExtendedInvocation defines model for ExtendedInvocation.
type ExtendedInvocation struct {
	// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
	// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
	// It acts as a bridge between ConfigHub and the infrastructure where configurations need
	// to be applied. Bridge workers are responsible for executing configuration changes on
	// remote targets and reporting status back to ConfigHub.
	// When starting a bridge worker program, both the BridgeWorkerID and Secret are
	// required for authentication with the ConfigHub server. These credentials allow the
	// bridge worker to establish a secure connection and receive configuration actions.
	BridgeWorker *BridgeWorker  `json:"BridgeWorker,omitempty"`
	Error        *ResponseError `json:"Error,omitempty"`

	// Invocation Defines a function invocation.
	Invocation *Invocation `json:"Invocation,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`
}

// ExtendedLink defines model for ExtendedLink.
type ExtendedLink struct {
	Error *ResponseError `json:"Error,omitempty"`

	// FromUnit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single *transaction*
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	FromUnit *Unit `json:"FromUnit,omitempty"`

	// Link Link connects two config Units in a dependency / producer-consumer relationship.
	// A Link indicates that config values Provided by the To Unit (the producer) may
	// satisfy config values Needed by the From Unit (the consumer), and should be attempted
	// to be matched before values Provided by other Units in the Space (if within the same
	// Space). Links must be created in the same Space as the From Unit.
	// They also imply an ordering when Applied or Destroyed as a Set.
	Link *Link `json:"Link,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// ToSpace The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	ToSpace *Space `json:"ToSpace,omitempty"`

	// ToUnit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single *transaction*
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	ToUnit *Unit `json:"ToUnit,omitempty"`
}

// ExtendedMutation defines model for ExtendedMutation.
type ExtendedMutation struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Invocation Defines a function invocation.
	Invocation *Invocation `json:"Invocation,omitempty"`

	// Link Link connects two config Units in a dependency / producer-consumer relationship.
	// A Link indicates that config values Provided by the To Unit (the producer) may
	// satisfy config values Needed by the From Unit (the consumer), and should be attempted
	// to be matched before values Provided by other Units in the Space (if within the same
	// Space). Links must be created in the same Space as the From Unit.
	// They also imply an ordering when Applied or Destroyed as a Set.
	Link *Link `json:"Link,omitempty"`

	// Mutation Mutation is a single source of mutation for a Revision.
	Mutation *Mutation `json:"Mutation,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Revision Revision is a historial view of a Config Unit.
	Revision *Revision `json:"Revision,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Trigger Defines an automated function invocation that executes in response to specific
	// Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
	// automated transformations, or other custom logic that should run when configuration
	// changes occur. Each Trigger is associated with a specific Space and can be configured
	// to execute on events.
	//
	// Triggers can be either validating (checking configuration validity without modifying it)
	// or mutating (making changes to the configuration). They can also be enforced (cannot be
	// overridden) or disabled.
	Trigger *Trigger `json:"Trigger,omitempty"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single *transaction*
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit *Unit `json:"Unit,omitempty"`
}

// ExtendedRevision defines model for ExtendedRevision.
type ExtendedRevision struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Revision Revision is a historial view of a Config Unit.
	Revision *Revision `json:"Revision,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single *transaction*
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit *Unit `json:"Unit,omitempty"`

	// User a User in Confighub.
	User *User `json:"User,omitempty"`
}

// ExtendedSet defines model for ExtendedSet.
type ExtendedSet struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Set A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
	Set *Set `json:"Set,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`
}

// ExtendedSpace defines model for ExtendedSpace.
type ExtendedSpace struct {
	Error                    *ResponseError `json:"Error,omitempty"`
	GatedUnitCount           int64          `json:"GatedUnitCount,omitempty"`
	IncompleteApplyUnitCount int64          `json:"IncompleteApplyUnitCount,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization          *Organization `json:"Organization,omitempty"`
	RecentChangeUnitCount int64         `json:"RecentChangeUnitCount,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space                      *Space         `json:"Space,omitempty"`
	TargetCountByToolchainType map[string]int `json:"TargetCountByToolchainType"`
	TotalBridgeWorkerCount     int64          `json:"TotalBridgeWorkerCount,omitempty"`
	TotalUnitCount             int64          `json:"TotalUnitCount,omitempty"`
	TriggerCountByEventType    map[string]int `json:"TriggerCountByEventType"`
	UnappliedUnitCount         int64          `json:"UnappliedUnitCount,omitempty"`
	UnapprovedUnitCount        int64          `json:"UnapprovedUnitCount,omitempty"`
	UnlinkedUnitCount          int64          `json:"UnlinkedUnitCount,omitempty"`
	UpgradableUnitCount        int64          `json:"UpgradableUnitCount,omitempty"`
}

// ExtendedTag defines model for ExtendedTag.
type ExtendedTag struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Tag Defines a Tag that can be used to identify a set of Revisions across Units.
	Tag *Tag `json:"Tag,omitempty"`
}

// ExtendedTarget defines model for ExtendedTarget.
type ExtendedTarget struct {
	// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
	// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
	// It acts as a bridge between ConfigHub and the infrastructure where configurations need
	// to be applied. Bridge workers are responsible for executing configuration changes on
	// remote targets and reporting status back to ConfigHub.
	// When starting a bridge worker program, both the BridgeWorkerID and Secret are
	// required for authentication with the ConfigHub server. These credentials allow the
	// bridge worker to establish a secure connection and receive configuration actions.
	BridgeWorker *BridgeWorker  `json:"BridgeWorker,omitempty"`
	Error        *ResponseError `json:"Error,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Target Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
	Target *Target `json:"Target,omitempty"`
}

// ExtendedTrigger defines model for ExtendedTrigger.
type ExtendedTrigger struct {
	// BridgeWorker BridgeWorker represents a bridge worker in ConfigHub.
	// A bridge worker is a worker program that connects ConfigHub to external systems and targets.
	// It acts as a bridge between ConfigHub and the infrastructure where configurations need
	// to be applied. Bridge workers are responsible for executing configuration changes on
	// remote targets and reporting status back to ConfigHub.
	// When starting a bridge worker program, both the BridgeWorkerID and Secret are
	// required for authentication with the ConfigHub server. These credentials allow the
	// bridge worker to establish a secure connection and receive configuration actions.
	BridgeWorker *BridgeWorker  `json:"BridgeWorker,omitempty"`
	Error        *ResponseError `json:"Error,omitempty"`

	// Invocation Defines a function invocation.
	Invocation *Invocation `json:"Invocation,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Trigger Defines an automated function invocation that executes in response to specific
	// Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
	// automated transformations, or other custom logic that should run when configuration
	// changes occur. Each Trigger is associated with a specific Space and can be configured
	// to execute on events.
	//
	// Triggers can be either validating (checking configuration validity without modifying it)
	// or mutating (making changes to the configuration). They can also be enforced (cannot be
	// overridden) or disabled.
	Trigger *Trigger `json:"Trigger,omitempty"`
}

// ExtendedUnit Unit with capability to extend additional related entities.
type ExtendedUnit struct {
	// ApprovedBy the users that have approved the latest revision of the config data.
	ApprovedBy []User         `json:"ApprovedBy,omitempty"`
	Error      *ResponseError `json:"Error,omitempty"`

	// HeadMutation Mutation is a single source of mutation for a Revision.
	HeadMutation *Mutation `json:"HeadMutation,omitempty"`

	// HeadRevision Revision is a historial view of a Config Unit.
	HeadRevision *Revision `json:"HeadRevision,omitempty"`

	// LastAppliedRevision Revision is a historial view of a Config Unit.
	LastAppliedRevision *Revision `json:"LastAppliedRevision,omitempty"`

	// LatestUnitEvent UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks
	// the lifecycle of applying, destroying, or refreshing a Unit's configuration in the target
	// live system. The event captures the current status of the operation, any configuration
	// drift detected, and timing information about when the action started and completed.
	// Actions are atomic from ConfigHub's perspective but may involve multiple steps
	// in the connected Bridge. The status and drift detection help track the health
	// and consistency of the provisioned configuration compared to what is defined in the Unit.
	LatestUnitEvent *UnitEvent `json:"LatestUnitEvent,omitempty"`

	// LiveRevision Revision is a historial view of a Config Unit.
	LiveRevision *Revision `json:"LiveRevision,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Set A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
	Set *Set `json:"Set,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// Target Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
	Target *Target `json:"Target,omitempty"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single *transaction*
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit       *Unit       `json:"Unit,omitempty"`
	UnitStatus *UnitStatus `json:"UnitStatus,omitempty"`

	// UpstreamSpace The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	UpstreamSpace *Space `json:"UpstreamSpace,omitempty"`

	// UpstreamUnit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single *transaction*
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	UpstreamUnit *Unit `json:"UpstreamUnit,omitempty"`
}

// ExtendedView defines model for ExtendedView.
type ExtendedView struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Filter Defines an entity filter.
	Filter *Filter `json:"Filter,omitempty"`

	// Organization The top-level container for an organization using ConfigHub.
	Organization *Organization `json:"Organization,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`

	// View Defines an entity view.
	View *View `json:"View,omitempty"`
}

// Filter Defines an entity filter.
type Filter struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// FilterID FilterID uniquely identifies a filter within the system.
	FilterID openapi_types.UUID `json:"FilterID,omitempty"`

	// From From specifies the type of entity (Unit, Space, etc.) to filter, in PascalCase.
	From        string `json:"From"`
	FromSpaceID *UUID  `json:"FromSpaceID"`

	// Hash SHA256 hash of the filter parameters encoded as hexadecimal. (readonly)
	Hash string `json:"Hash,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// ResourceType Resource type to match for the desired ToolchainType, for example apps/v1/Deployment. Valid only for Units. (optional)
	ResourceType string `json:"ResourceType,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`

	// Where Where specifices the where filter expression in the syntax used in list and search API query parameters. (optional)
	Where string `json:"Where,omitempty"`

	// WhereData WhereData specifies a filter expression for configuration data. Valid only for Units. (optional)
	WhereData string `json:"WhereData,omitempty"`
}

// FilterCreateOrUpdateResponse defines model for FilterCreateOrUpdateResponse.
type FilterCreateOrUpdateResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Filter Defines an entity filter.
	Filter *Filter `json:"Filter,omitempty"`
}

// FunctionArgument defines model for FunctionArgument.
type FunctionArgument struct {
	ParameterName *string                 `json:"ParameterName,omitempty"`
	Value         *FunctionArgument_Value `json:"Value,omitempty"`
}

// FunctionArgumentValue0 defines model for .
type FunctionArgumentValue0 = string

// FunctionArgumentValue1 defines model for .
type FunctionArgumentValue1 = int64

// FunctionArgumentValue2 defines model for .
type FunctionArgumentValue2 = bool

// FunctionArgument_Value defines model for FunctionArgument.Value.
type FunctionArgument_Value struct {
	union json.RawMessage
}

// FunctionInvocation defines model for FunctionInvocation.
type FunctionInvocation struct {
	// Arguments Function arguments
	Arguments []FunctionArgument `json:"Arguments"`

	// FunctionName Function name
	FunctionName string `json:"FunctionName,omitempty"`
}

// FunctionInvocationList defines model for FunctionInvocationList.
type FunctionInvocationList = []FunctionInvocation

// FunctionInvocationsRequest FunctionInvocationsRequest represents a request to invoke a list of functions on the configuration data of the matching Units or Revision.
type FunctionInvocationsRequest struct {
	BridgeWorkerID *UUID `json:"BridgeWorkerID"`

	// CastStringArgsToScalars CastStringArgsToScalars indicates whether to expect string arguments and cast them to int and bool types as necessary.
	CastStringArgsToScalars bool `json:"CastStringArgsToScalars,omitempty"`

	// ChangeDescription ChangeDescription is a description of the change being made, if any.
	ChangeDescription string `json:"ChangeDescription,omitempty"`

	// CombineResults CombineResults indicates whether to combine the Outputs of all functions in the FunctionInvocations list. In the case of ValidationResult, the Passed results are ANDed together and a single ValidationResult is returned instead of a ValidationResultList. In the case of AttributeValueList and ResourceInfoList, the lists are concatenated. All output-generating functions must return the same OutputType, or only the first OutputType will be returned. Note that this applies to each Unit or Revision individually rather than all of the entities on which the functions are being invoked.
	CombineResults      bool                    `json:"CombineResults,omitempty"`
	FunctionInvocations *FunctionInvocationList `json:"FunctionInvocations"`

	// NumFilters NumFilters is the number of validating functions from the FunctionInvocations to treat as filters for the remaining functions in the list. In the case that the validation function does not pass, stop and don't execute the remaining functions, but don't report an error.
	NumFilters int `json:"NumFilters,omitempty"`

	// StopOnError StopOnError indicates whether to stop executing functions from the FunctionInvocations list on the first error, or to execute all of the functions and return all of the errors. Note that this applies to each Unit or Revision individually rather than all of the entities on which the functions are being invoked.
	StopOnError bool `json:"StopOnError,omitempty"`

	// UseFunctionWorker UseFunctionWorker indicates whether to use the function worker or the builtin function executor, which is the default. The FunctionInvocations are forwarded to the executor/worker, so all must be executable by the same executor/worker currently.
	UseFunctionWorker bool `json:"UseFunctionWorker,omitempty"`
}

// FunctionInvocationsResponse defines model for FunctionInvocationsResponse.
type FunctionInvocationsResponse struct {
	// ConfigData The resulting configuration data, potentially mutated
	ConfigData string                `json:"ConfigData,omitempty"`
	Error      *ResponseError        `json:"Error,omitempty"`
	Mutations  *ResourceMutationList `json:"Mutations"`

	// Mutators List of function invocation indices that resulted in mutations
	Mutators []int `json:"Mutators"`

	// OrganizationID ID of the Unit's Organization
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Output Output other than config data, as embedded JSON
	Output string `json:"Output,omitempty"`

	// OutputType Type of structured function output, if any
	OutputType string `json:"OutputType,omitempty"`

	// RevisionID ID of the Revision the configuration data is associated with
	RevisionID openapi_types.UUID `json:"RevisionID,omitempty"`

	// SpaceID ID of the Unit's Space
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// Success True if all functions executed successfully
	Success bool `json:"Success,omitempty"`

	// UnitID ID of the Unit the configuration data is associated with
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`
}

// FunctionOutput defines model for FunctionOutput.
type FunctionOutput struct {
	// Description Description of the result
	Description string `json:"Description,omitempty"`

	// OutputType Data type of the JSON embedded in the output
	OutputType string `json:"OutputType,omitempty"`

	// ResultName Name of the result in kabob-case
	ResultName string `json:"ResultName,omitempty"`
}

// FunctionParameter defines model for FunctionParameter.
type FunctionParameter struct {
	// DataType Data type of the parameter
	DataType string `json:"DataType,omitempty"`

	// Description Description of the parameter
	Description string `json:"Description,omitempty"`

	// EnumValues List of valid enum values; applies to enum parameters
	EnumValues []string `json:"EnumValues,omitempty"`

	// Example Example value
	Example string `json:"Example,omitempty"`

	// Max Maximum allowed value; applies to int parameters
	Max int `json:"Max"`

	// Min Minimum allowed value; applies to int parameters
	Min int `json:"Min"`

	// ParameterName Name of the parameter in kabob-case
	ParameterName string `json:"ParameterName,omitempty"`

	// Regexp Regular expression matching valid values; applies to string parameters
	Regexp string `json:"Regexp,omitempty"`

	// Required Whether the parameter is required
	Required bool `json:"Required,omitempty"`
}

// FunctionSignature defines model for FunctionSignature.
type FunctionSignature struct {
	// AffectedResourceTypes Resource types the function applies to; * if all
	AffectedResourceTypes []string `json:"AffectedResourceTypes,omitempty"`

	// AttributeName Attribute corresponding to registered paths, if a path visitor; optional
	AttributeName string `json:"AttributeName,omitempty"`

	// Description Description of the function
	Description string `json:"Description,omitempty"`

	// FunctionName Name of the function in kabob-case
	FunctionName string `json:"FunctionName,omitempty"`

	// FunctionType Implementation pattern of the function: PathVisitor or Custom
	FunctionType string `json:"FunctionType,omitempty"`

	// Hermetic Does not call other systems
	Hermetic bool `json:"Hermetic,omitempty"`

	// Idempotent Will return the same result if invoked again
	Idempotent bool `json:"Idempotent,omitempty"`

	// Mutating May change the configuration data
	Mutating   bool            `json:"Mutating,omitempty"`
	OutputInfo *FunctionOutput `json:"OutputInfo,omitempty"`

	// Parameters Function parameters, in order
	Parameters []FunctionParameter `json:"Parameters"`

	// RequiredParameters Number of required parameters
	RequiredParameters int `json:"RequiredParameters,omitempty"`

	// Validating Returns ValidationResult
	Validating bool `json:"Validating,omitempty"`

	// VarArgs Last parameter may be repeated
	VarArgs bool `json:"VarArgs,omitempty"`
}

// FunctionWorkerInfo defines model for FunctionWorkerInfo.
type FunctionWorkerInfo struct {
	SupportedFunctions map[string]map[string]FunctionSignature `json:"SupportedFunctions"`
}

// ImportFilter defines model for ImportFilter.
type ImportFilter struct {
	Operator string   `json:"Operator,omitempty"`
	Type     string   `json:"Type,omitempty"`
	Values   []string `json:"Values,omitempty"`
}

// ImportOptions defines model for ImportOptions.
type ImportOptions map[string]interface{}

// ImportRequest defines model for ImportRequest.
type ImportRequest struct {
	Filters          []ImportFilter    `json:"Filters,omitempty"`
	Options          *ImportOptions    `json:"Options,omitempty"`
	ResourceInfoList *ResourceInfoList `json:"ResourceInfoList,omitempty"`
	Where            string            `json:"Where,omitempty"`
}

// Invocation Defines a function invocation.
type Invocation struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// Arguments Function arguments
	Arguments      []FunctionArgument `json:"Arguments"`
	BridgeWorkerID *UUID              `json:"BridgeWorkerID"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// FunctionName Function name
	FunctionName string `json:"FunctionName,omitempty"`

	// Hash SHA256 hash of the function name and arguments encoded as hexadecimal.
	Hash string `json:"Hash,omitempty"`

	// InvocationID InvocationID uniquely identifies a invocation within the system.
	InvocationID openapi_types.UUID `json:"InvocationID,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// ToolchainType ToolchainType specifies the type of toolchain this invocation works with.
	// 		This determines which configuration formats the invocation can process.
	ToolchainType string `json:"ToolchainType"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// InvocationCreateOrUpdateResponse defines model for InvocationCreateOrUpdateResponse.
type InvocationCreateOrUpdateResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Invocation Defines a function invocation.
	Invocation *Invocation `json:"Invocation,omitempty"`
}

// Link Link connects two config Units in a dependency / producer-consumer relationship.
// A Link indicates that config values Provided by the To Unit (the producer) may
// satisfy config values Needed by the From Unit (the consumer), and should be attempted
// to be matched before values Provided by other Units in the Space (if within the same
// Space). Links must be created in the same Space as the From Unit.
// They also imply an ordering when Applied or Destroyed as a Set.
type Link struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// FromUnitID Unique identifier the Unit the Link initiates from. Links must be in the same space as the source unit.
	FromUnitID openapi_types.UUID `json:"FromUnitID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// LinkID Unique identifier for a Link.
	LinkID openapi_types.UUID `json:"LinkID,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// ToSpaceID Unique identifier the Space of the Unit the Link targets.
	ToSpaceID openapi_types.UUID `json:"ToSpaceID,omitempty"`

	// ToUnitID Unique identifier the Unit the Link targets.
	ToUnitID openapi_types.UUID `json:"ToUnitID"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// LinkCreateOrUpdateResponse defines model for LinkCreateOrUpdateResponse.
type LinkCreateOrUpdateResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Link Link connects two config Units in a dependency / producer-consumer relationship.
	// A Link indicates that config values Provided by the To Unit (the producer) may
	// satisfy config values Needed by the From Unit (the consumer), and should be attempted
	// to be matched before values Provided by other Units in the Space (if within the same
	// Space). Links must be created in the same Space as the From Unit.
	// They also imply an ordering when Applied or Destroyed as a Set.
	Link *Link `json:"Link,omitempty"`
}

// Mutation Mutation is a single source of mutation for a Revision.
type Mutation struct {
	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// EntityType The type of entity.
	EntityType         string              `json:"EntityType,omitempty"`
	FunctionInvocation *FunctionInvocation `json:"FunctionInvocation,omitempty"`
	InvocationID       *UUID               `json:"InvocationID"`
	LinkID             *UUID               `json:"LinkID"`

	// MutationID Unique identifier for a Mutation.
	MutationID openapi_types.UUID `json:"MutationID,omitempty"`

	// MutationNum Sequence number for the Mutation.
	MutationNum int64 `json:"MutationNum,omitempty"`

	// OrganizationID Unique identifier for an Organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// ProvidedPath ProvidedPath is the path of the provided value used to satisfy a needed value if the change was made due to resolving a link.
	ProvidedPath     string        `json:"ProvidedPath,omitempty"`
	ProvidedResource *ResourceInfo `json:"ProvidedResource,omitempty"`

	// RestoredRevisionNum Sequence number of the restored revision, if the change was due to a restore operation.
	RestoredRevisionNum int64 `json:"RestoredRevisionNum,omitempty"`

	// RevisionID Unique identifier of the corresponding Revision.
	RevisionID openapi_types.UUID `json:"RevisionID,omitempty"`

	// RevisionNum Sequence number of the corresponding Revision.
	RevisionNum int64 `json:"RevisionNum,omitempty"`

	// SpaceID Unique identifier for a space.
	SpaceID   openapi_types.UUID `json:"SpaceID,omitempty"`
	TriggerID *UUID              `json:"TriggerID"`

	// UnitID Unique identifier for a Unit.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// UpgradedFromUpstreamRevisionNum Sequence number of the upstream revision the unit was upgraded from, if the change was due to an upgrade operation.
	UpgradedFromUpstreamRevisionNum int64 `json:"UpgradedFromUpstreamRevisionNum,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// MutationInfo defines model for MutationInfo.
type MutationInfo struct {
	// Index Function index or sequence number corresponding to the change
	Index        int64         `json:"Index,omitempty"`
	MutationType *MutationType `json:"MutationType,omitempty"`

	// Predicate Used to decide how to use the mututation
	Predicate bool `json:"Predicate,omitempty"`

	// Value Removed configuration data if MutationType is Delete and otherwise the new data
	Value string `json:"Value,omitempty"`
}

// MutationMap defines model for MutationMap.
type MutationMap map[string]MutationInfo

// MutationType defines model for MutationType.
type MutationType string

// Organization The top-level container for an organization using ConfigHub.
type Organization struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// BillingAccountID Unique identifier for a billing account for the organization. Set to the BillingAccountID of the authenticated Organization.
	BillingAccountID openapi_types.UUID `json:"BillingAccountID,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// ExternalID Unique identifier for the External Identity Provider record matching this organization.
	ExternalID string `json:"ExternalID,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// OrganizationMember a User given membership on the Organization
type OrganizationMember struct {
	// DisplayName Friendly name for the organization member User.
	DisplayName string `json:"DisplayName,omitempty"`

	// ExternalID Unique identifier for the External Identity Provider record matching this User.
	ExternalID string `json:"ExternalID,omitempty"`

	// ExternalOrganizationID Unique identifier for the External Identity Provider record matching this organization.
	ExternalOrganizationID string `json:"ExternalOrganizationID,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// ProfilePictureURL The URL to get the profile avatar picture of the User.
	ProfilePictureURL string `json:"ProfilePictureURL,omitempty"`

	// Slug Unique URL-safe identifier for the organization member User.
	Slug string `json:"Slug,omitempty"`

	// UserID Unique identifier for the organization member User.
	UserID openapi_types.UUID `json:"UserID,omitempty"`

	// Username Unique username for a User. Must be unique for all of ConfigHub.
	Username string `json:"Username,omitempty"`
}

// QueuedOperation QueuedOperation is a record of an operation to be done by a bridge worker.
type QueuedOperation struct {
	Action *ActionType `json:"Action,omitempty"`

	// BridgeWorkerID BridgeWorkerID is the unique identifier of the bridge worker that will process this operation.
	BridgeWorkerID openapi_types.UUID `json:"BridgeWorkerID,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// ExtraParams ExtraParams contains additional parameters for the operation in string format.
	ExtraParams string `json:"ExtraParams,omitempty"`

	// OrganizationID OrganizationID is the unique identifier of the organization this operation belongs to.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// QueuedOperationID QueuedOperationID is the unique identifier for the queued operation.
	QueuedOperationID openapi_types.UUID `json:"QueuedOperationID,omitempty"`

	// RevisionNum RevisionNum is the revision number this operation was performed on.
	RevisionNum int64 `json:"RevisionNum,omitempty"`

	// SpaceID SpaceID is the unique identifier of the space of the unit this operation is performed on.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// Status Status indicates the current status of the queued operation.
	Status string `json:"Status,omitempty"`

	// TargetID TargetID is the unique identifier of the target this operation is directed to.
	TargetID openapi_types.UUID `json:"TargetID,omitempty"`

	// UnitID UnitID is the unique identifier of the unit this operation is performed on.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// ResourceInfo defines model for ResourceInfo.
type ResourceInfo struct {
	// ResourceCategory Category of configuration element represented in the configuration data; Kubernetes and OpenTofu resources are of category Resource, and application configuration files are of category AppConfig
	ResourceCategory string `json:"ResourceCategory,omitempty"`

	// ResourceName Name of a resource in the system under management represented in the configuration data; Kubernetes resources are represented in the form <metadata.namespace>/<metadata.name>; not all ToolchainTypes necessarily use '/' as a separator between any scope(s) and name or other client-chosen ID
	ResourceName string `json:"ResourceName,omitempty"`

	// ResourceNameWithoutScope Name of a resource in the system under management represented in the configuration data, without any uniquifying scope, such as Namespace, Project, Account, Region, etc.; Kubernetes resources are represented in the form <metadata.name>
	ResourceNameWithoutScope string `json:"ResourceNameWithoutScope,omitempty"`

	// ResourceType Type of a resource in the system under management represented in the configuration data; Kubernetes resources are represented in the form <apiVersion>/<kind> (aka group-version-kind)
	ResourceType string `json:"ResourceType,omitempty"`
}

// ResourceInfoList defines model for ResourceInfoList.
type ResourceInfoList = []ResourceInfo

// ResourceMutation defines model for ResourceMutation.
type ResourceMutation struct {
	// Aliases Names (with scopes, if any) used in current and prior revisions of this resource
	Aliases map[string]map[string]interface{} `json:"Aliases,omitempty"`

	// AliasesWithoutScopes Names without scopes used in current and prior revisions of this resource
	AliasesWithoutScopes map[string]map[string]interface{} `json:"AliasesWithoutScopes,omitempty"`
	PathMutationMap      *MutationMap                      `json:"PathMutationMap,omitempty"`
	Resource             *ResourceInfo                     `json:"Resource,omitempty"`
	ResourceMutationInfo *MutationInfo                     `json:"ResourceMutationInfo,omitempty"`
}

// ResourceMutationList defines model for ResourceMutationList.
type ResourceMutationList = []ResourceMutation

// ResponseError defines model for ResponseError.
type ResponseError struct {
	// Details Additional context messages
	Details []string `json:"Details,omitempty"`

	// ErrorCategory The type of error (e.g., validation, not-found)
	ErrorCategory string         `json:"ErrorCategory,omitempty"`
	ErrorMetadata *ErrorMetadata `json:"ErrorMetadata,omitempty"`

	// Message The primary error message
	Message string `json:"Message,omitempty"`

	// Status HTTP status code
	Status int `json:"Status,omitempty"`

	// Type The type of error (e.g., validation, not-found)
	Type string `json:"Type,omitempty"`
}

// Revision Revision is a historial view of a Config Unit.
type Revision struct {
	// ApplyGates A map of "<trigger slug>/<function name>" to true of Triggers invoking validating functions that did not pass on the configuration data at this Revision.
	ApplyGates map[string]bool `json:"ApplyGates,omitempty"`

	// ApprovedBy the users that have approved the latest version of the config data for the Unit.
	ApprovedBy []UUID `json:"ApprovedBy,omitempty"`

	// ContentHash The CRC32 hash of this revision's data.
	ContentHash int `json:"ContentHash,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// Data The full configuration data for this unit at this revision.
	Data string `json:"Data,omitempty"`

	// Description User description of the change. It is copied from the LastChangeDescription field of the Unit at the time the change was made that created the Revision.
	Description string `json:"Description,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// LiveAt Time at which the revision was applied, if it was applied. If not applied, the value is "0001-01-01T00:00:00Z".
	LiveAt          time.Time             `json:"LiveAt,omitempty"`
	MutationSources *ResourceMutationList `json:"MutationSources"`

	// OrganizationID Unique identifier for an Organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// RevisionID Unique identifier for a Revision.
	RevisionID openapi_types.UUID `json:"RevisionID,omitempty"`

	// RevisionNum Sequence number for a Revision.
	RevisionNum int64 `json:"RevisionNum,omitempty"`

	// Source ConfigHub operation that created this revision.
	Source string `json:"Source,omitempty"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// Tags A set (map) of TagIDs of any Tags applied to this Revision. The string values have no particular meaning for now.
	Tags map[string]string `json:"Tags,omitempty"`

	// UnitID Unique identifier for a Unit.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// UserAgent User-Agent string if created by an API call. Optional.
	UserAgent string `json:"UserAgent,omitempty"`

	// UserID UserID if change was made by a user. Automated changes, such as by triggers and resolve, are currently made with the UserID "00000000-0000-0000-0000-000000000000".
	UserID openapi_types.UUID `json:"UserID,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// Set A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
type Set struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// SetID Unique identifier for a Set.
	SetID openapi_types.UUID `json:"SetID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
type Space struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// SpaceCreateOrUpdateResponse defines model for SpaceCreateOrUpdateResponse.
type SpaceCreateOrUpdateResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Space The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
	Space *Space `json:"Space,omitempty"`
}

// StandardErrorResponse Error response details.
type StandardErrorResponse struct {
	// Code HTTP status code of the response.
	Code string `json:"Code,omitempty"`

	// Message Message returned with the response.
	Message string `json:"Message,omitempty"`
}

// Tag Defines a Tag that can be used to identify a set of Revisions across Units.
type Tag struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// TagID TagID uniquely identifies a tag within the system.
	TagID openapi_types.UUID `json:"TagID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// TagCreateOrUpdateResponse defines model for TagCreateOrUpdateResponse.
type TagCreateOrUpdateResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Tag Defines a Tag that can be used to identify a set of Revisions across Units.
	Tag *Tag `json:"Tag,omitempty"`
}

// Target Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
type Target struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// BridgeWorkerID Unique identifier for a Bridge Worker associated with the Target.
	BridgeWorkerID openapi_types.UUID `json:"BridgeWorkerID"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Parameters Parameters contains toolchain-type and/or provider-type-specific parameters in JSON format.
	//
	// For ProviderType: Kubernetes (ToolchainType: Kubernetes/YAML)
	// The Parameters object may contain the following fields:
	// - "KubeContext" (string): The name of the Kubernetes context (from "~/.kube/config") to use. (Not typically needed if running in-cluster).
	// - "KubeNamespace" (string, optional): The target Kubernetes namespace for applying or managing resources.
	// - "WaitTimeout" (string): A duration string (e.g., "5m", "2m30s") specifying how long to wait for resources to reach a ready state. Defaults to "2m0s".
	//
	// For ProviderType: FluxOCIWriter (ToolchainType: Kubernetes/YAML)
	// The Parameters object may contain the following fields:
	// - "Repository" (string, required): The base OCI repository URL (e.g., "oci://ghcr.io/my-org"). The 'UnitSlug' (a system-provided identifier for the configuration unit) will be appended to this URL to form the full image path (e.g., "oci://ghcr.io/my-org/<UnitSlug>").
	// - "Tag" (string, optional): Explicit OCI tag for the image. Confighub will automatically set the tag on each push using the Unit's current RevisionNum being applied. This will have 'rev' prefixed to the number, like 'rev42'. When Tag is populated, it can be used to explicitly set a value that you want Confighub to publish to the OCI in addition to the default RevisionNum tag. For example 'latest' or 'trunk'.
	// - "Provider" (string, optional): Specifies the authentication provider for the OCI registry. Defaults to "None".
	//     Possible values:
	//     - "None": Uses local Docker configuration (e.g., from '~/.docker/config.json') or the system's credential keychain.
	//     - "Generic": Uses generic OCI provider authentication.
	//     - "AWS": Uses AWS ECR authentication.
	//     - "Azure": Uses Azure CR authentication.
	//     - "GCP": Uses Google CR/Artifact Registry authentication.
	// - "AllowDeletion" (string, optional): A boolean string ("true" or "false") indicating if the worker is allowed to delete images from the repository. Defaults to "false".
	// - "KubernetesSecretName" (string, optional): The name of a Kubernetes Secret containing Docker credentials. The secret should typically have a '.dockerconfigjson' key, or 'username' and 'password' keys.
	// - "KubernetesSecretNamespace" (string, optional): The Kubernetes namespace where the "KubernetesSecretName" is located. If not specified, the secret is assumed to be in the same namespace as the ConfigHub worker.
	Parameters string `json:"Parameters,omitempty"`

	// ProviderType ProviderType specifies the cloud or infrastructure provider for this target, such as "Kubernetes" or "AWS".
	ProviderType string `json:"ProviderType"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// TargetID Unique identifier for a Target.
	TargetID openapi_types.UUID `json:"TargetID,omitempty"`

	// ToolchainType ToolchainType specifies the type of toolchain supported by this Target. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
	ToolchainType string `json:"ToolchainType"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// TargetCreateOrUpdateResponse defines model for TargetCreateOrUpdateResponse.
type TargetCreateOrUpdateResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Target Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
	Target *Target `json:"Target,omitempty"`
}

// TargetType2 defines model for TargetType2.
type TargetType2 struct {
	// Name Used to set the Slug and DisplayName of the Target created in ConfigHub
	Name string `json:"Name,omitempty"`

	// Params Used to set the Parameters of the Target created in ConfigHub
	Params map[string]interface{} `json:"Params,omitempty"`
}

// Trigger Defines an automated function invocation that executes in response to specific
// Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
// automated transformations, or other custom logic that should run when configuration
// changes occur. Each Trigger is associated with a specific Space and can be configured
// to execute on events.
//
// Triggers can be either validating (checking configuration validity without modifying it)
// or mutating (making changes to the configuration). They can also be enforced (cannot be
// overridden) or disabled.
type Trigger struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// Arguments Function arguments
	Arguments      []FunctionArgument `json:"Arguments"`
	BridgeWorkerID *UUID              `json:"BridgeWorkerID"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// Disabled Disabled indicates whether this trigger is currently disabled.
	// 		When disabled, the trigger will not be executed even when matching events occur.
	Disabled bool `json:"Disabled,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// Enforced Enforced indicates whether this trigger cannot be overridden.
	// 		Enforced triggers implement mandatory policies that cannot be bypassed.
	Enforced bool `json:"Enforced,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// Event Event specifies the type of event that will activate this trigger. Valid values are Mutation, PreClone, and PostClone
	Event string `json:"Event"`

	// FunctionName Function name
	FunctionName string `json:"FunctionName,omitempty"`
	InvocationID *UUID  `json:"InvocationID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// ToolchainType ToolchainType specifies the type of toolchain this trigger works with.
	// 		This determines which configuration formats the trigger can process.
	ToolchainType string `json:"ToolchainType"`

	// TriggerID TriggerID uniquely identifies a trigger within the system.
	TriggerID openapi_types.UUID `json:"TriggerID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Validating Validating indicates whether this is a validating function (true) or mutating function (false).
	// 		Validating functions check configuration validity without modifying it. Mutating functions can make changes to the configuration.
	// 		This value is returned by ConfigHub based on the corresponding property of the specified function.
	Validating bool `json:"Validating,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// TriggerCreateOrUpdateResponse defines model for TriggerCreateOrUpdateResponse.
type TriggerCreateOrUpdateResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// Trigger Defines an automated function invocation that executes in response to specific
	// Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
	// automated transformations, or other custom logic that should run when configuration
	// changes occur. Each Trigger is associated with a specific Space and can be configured
	// to execute on events.
	//
	// Triggers can be either validating (checking configuration validity without modifying it)
	// or mutating (making changes to the configuration). They can also be enforced (cannot be
	// overridden) or disabled.
	Trigger *Trigger `json:"Trigger,omitempty"`
}

// UUID defines model for UUID.
type UUID = openapi_types.UUID

// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
// file. Applying / deploying or destroying the configuration happens as a single *transaction*
// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
// the underlying configuration / deployment tool. The resources must belong to a single
// infrastructure provider and the actuation mechanism must be able to resolve references and
// ordering dependencies among the resources within the document. For example, if one resource
// needs to be fully provisioned to provide input to another resource, then the actuation code is
// responsible for handling this. Revisions store historical copies of the configuration data.
// Configuration data can be restored from prior Revisions. Units can also be cloned to create
// new variants of a configuration.
type Unit struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// ApplyGates A map of "<trigger slug>/<function name>" to true of Triggers invoking validating functions that did not pass on the latest configuration data.
	ApplyGates map[string]bool `json:"ApplyGates,omitempty"`

	// ApprovedBy The users that have approved the latest revision of the config data for the Unit.
	ApprovedBy []UUID `json:"ApprovedBy"`

	// ContentHash The CRC32 hash of the configuration data.
	ContentHash int `json:"ContentHash,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// Data The full configuration data for this unit.
	Data string `json:"Data,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// HeadMutationNum Sequence number the head Mutation.
	HeadMutationNum int64 `json:"HeadMutationNum,omitempty"`

	// HeadRevisionNum Sequence number the head Revision.
	HeadRevisionNum int64 `json:"HeadRevisionNum,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// LastAppliedRevisionNum Sequence number the last Revision applied. 0 if no live revision.
	LastAppliedRevisionNum int64 `json:"LastAppliedRevisionNum,omitempty"`

	// LastChangeDescription LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.
	LastChangeDescription string `json:"LastChangeDescription,omitempty"`

	// LiveRevisionNum Sequence number the last Revision applied once apply has completed. 0 if no live revision.
	LiveRevisionNum int64 `json:"LiveRevisionNum,omitempty"`

	// LiveState The current live state of the Unit as reported by the bridge worker associated with the Target attached to the Unit.
	LiveState       string                `json:"LiveState,omitempty"`
	MutationSources *ResourceMutationList `json:"MutationSources"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Outputs The outputs of the last successful apply of the Unit.
	Outputs string `json:"Outputs,omitempty"`

	// PreviousLiveRevisionNum Sequence number the previous Revision applied. 0 if no live revision.
	PreviousLiveRevisionNum int64 `json:"PreviousLiveRevisionNum,omitempty"`
	SetID                   *UUID `json:"SetID"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID  openapi_types.UUID `json:"SpaceID,omitempty"`
	TargetID *UUID              `json:"TargetID"`

	// ToolchainType ToolchainType specifies the type of toolchain for this unit. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
	ToolchainType string `json:"ToolchainType"`

	// UnitID Unique identifier for a Unit.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt              time.Time `json:"UpdatedAt,omitempty"`
	UpstreamOrganizationID *UUID     `json:"UpstreamOrganizationID"`

	// UpstreamRevisionNum Sequence number for the Revision of the Unit this unit was cloned from, or 0. This is updated to the upstream Unit's head revision number when the Unit is upgraded.
	UpstreamRevisionNum int64 `json:"UpstreamRevisionNum,omitempty"`
	UpstreamSpaceID     *UUID `json:"UpstreamSpaceID"`
	UpstreamUnitID      *UUID `json:"UpstreamUnitID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// UnitActionResponse defines model for UnitActionResponse.
type UnitActionResponse struct {
	// Action QueuedOperation is a record of an operation to be done by a bridge worker.
	Action *QueuedOperation `json:"Action,omitempty"`
	Error  *ResponseError   `json:"Error,omitempty"`
}

// UnitCreateOrUpdateResponse defines model for UnitCreateOrUpdateResponse.
type UnitCreateOrUpdateResponse struct {
	Error *ResponseError               `json:"Error,omitempty"`
	Links []LinkCreateOrUpdateResponse `json:"Links,omitempty"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single *transaction*
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit *Unit `json:"Unit,omitempty"`
}

// UnitEvent UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks
// the lifecycle of applying, destroying, or refreshing a Unit's configuration in the target
// live system. The event captures the current status of the operation, any configuration
// drift detected, and timing information about when the action started and completed.
// Actions are atomic from ConfigHub's perspective but may involve multiple steps
// in the connected Bridge. The status and drift detection help track the health
// and consistency of the provisioned configuration compared to what is defined in the Unit.
type UnitEvent struct {
	Action         *ActionType `json:"Action,omitempty"`
	BridgeWorkerID *UUID       `json:"BridgeWorkerID"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`
	Message    string `json:"Message,omitempty"`

	// OrganizationID Unique identifier for an Organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// QueuedOperationID QueuedOperationID is the unique identifier for the corresponding queued operation.
	QueuedOperationID openapi_types.UUID `json:"QueuedOperationID,omitempty"`
	Result            *ActionResultType  `json:"Result,omitempty"`
	RevisionNum       int64              `json:"RevisionNum,omitempty"`

	// SpaceID Unique identifier for a space.
	SpaceID      openapi_types.UUID `json:"SpaceID,omitempty"`
	StartedAt    time.Time          `json:"StartedAt,omitempty"`
	Status       *ActionStatusType  `json:"Status,omitempty"`
	TerminatedAt time.Time          `json:"TerminatedAt"`
	UnitEventID  openapi_types.UUID `json:"UnitEventID,omitempty"`

	// UnitID Unique identifier for a Unit.
	UnitID openapi_types.UUID `json:"UnitID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// UnitExtended defines model for UnitExtended.
type UnitExtended struct {
	Action             *ActionType       `json:"Action,omitempty"`
	ActionResult       *ActionResultType `json:"ActionResult,omitempty"`
	ActionStartedAt    time.Time         `json:"ActionStartedAt"`
	ActionTerminatedAt time.Time         `json:"ActionTerminatedAt"`
	ApprovedByUsers    []string          `json:"ApprovedByUsers"`
	Drift              string            `json:"Drift,omitempty"`
	FromLinks          []Link            `json:"FromLinks"`
	Status             string            `json:"Status,omitempty"`
	ToLinks            []Link            `json:"ToLinks"`

	// Unit Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
	// of a single supported Toolchain Type (congifuration format). This blob is typically a text document
	// that contains a collection of Kubernetes or infrastructure resources, or an application configuration
	// file. Applying / deploying or destroying the configuration happens as a single *transaction*
	// from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
	// the underlying configuration / deployment tool. The resources must belong to a single
	// infrastructure provider and the actuation mechanism must be able to resolve references and
	// ordering dependencies among the resources within the document. For example, if one resource
	// needs to be fully provisioned to provide input to another resource, then the actuation code is
	// responsible for handling this. Revisions store historical copies of the configuration data.
	// Configuration data can be restored from prior Revisions. Units can also be cloned to create
	// new variants of a configuration.
	Unit *Unit `json:"Unit,omitempty"`
}

// UnitStatus defines model for UnitStatus.
type UnitStatus struct {
	Action             *ActionType       `json:"Action,omitempty"`
	ActionResult       *ActionResultType `json:"ActionResult,omitempty"`
	ActionStartedAt    time.Time         `json:"ActionStartedAt"`
	ActionTerminatedAt time.Time         `json:"ActionTerminatedAt"`
	Drift              string            `json:"Drift,omitempty"`
	Status             string            `json:"Status,omitempty"`
}

// UnitTagRequest defines model for UnitTagRequest.
type UnitTagRequest struct {
	// Revision Which Unit revision to tag: 'HeadRevisionNum', 'LiveRevisionNum', 'LastAppliedRevisionNum', or 'PreviousLiveRevisionNum'
	Revision string             `json:"Revision,omitempty"`
	TagID    openapi_types.UUID `json:"TagID,omitempty"`
}

// UnitTagResponse defines model for UnitTagResponse.
type UnitTagResponse struct {
	Error   *ResponseError `json:"Error,omitempty"`
	Message string         `json:"Message,omitempty"`
}

// User a User in Confighub.
type User struct {
	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// ExternalID Unique identifier for the External Identity Provider record matching this User.
	ExternalID string `json:"ExternalID,omitempty"`

	// ProfilePictureURL The URL to get the profile avatar picture of the User.
	ProfilePictureURL string `json:"ProfilePictureURL,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// UserID Unique identifier for a User.
	UserID openapi_types.UUID `json:"UserID,omitempty"`

	// Username Unique username for a User. Must be unique for all of Confighub.
	Username string `json:"Username,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// View Defines an entity view.
type View struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations map[string]string `json:"Annotations,omitempty"`

	// Columns Columns to display, in order. (optional)
	Columns []Column `json:"Columns,omitempty"`

	// CreatedAt The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	CreatedAt time.Time `json:"CreatedAt,omitempty"`

	// CursorID An auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// DisplayName Friendly name for the entity.
	DisplayName string `json:"DisplayName,omitempty"`

	// EntityType The type of entity.
	EntityType string `json:"EntityType,omitempty"`

	// FilterID FilterID identifies a filter. (required)
	FilterID openapi_types.UUID `json:"FilterID"`

	// GroupBy Column to group by (optional).
	GroupBy string `json:"GroupBy,omitempty"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels map[string]string `json:"Labels,omitempty"`

	// OrderBy Column to sort by. (optional)
	OrderBy string `json:"OrderBy,omitempty"`

	// OrderByDirection Columnn sort order, ASC or DESC. Default is ASC. Only should be specified if OrderBy is specified. (optional)
	OrderByDirection string `json:"OrderByDirection,omitempty"`

	// OrganizationID Unique identifier for an organization.
	OrganizationID openapi_types.UUID `json:"OrganizationID,omitempty"`

	// Slug Unique URL-safe identifier for the entity.
	Slug string `json:"Slug"`

	// SpaceID Unique identifier for a space.
	SpaceID openapi_types.UUID `json:"SpaceID,omitempty"`

	// UpdatedAt The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	UpdatedAt time.Time `json:"UpdatedAt,omitempty"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`

	// ViewID ViewID uniquely identifies a view within the system.
	ViewID openapi_types.UUID `json:"ViewID,omitempty"`
}

// ViewCreateOrUpdateResponse defines model for ViewCreateOrUpdateResponse.
type ViewCreateOrUpdateResponse struct {
	Error *ResponseError `json:"Error,omitempty"`

	// View Defines an entity view.
	View *View `json:"View,omitempty"`
}

// WorkerInfo defines model for WorkerInfo.
type WorkerInfo struct {
	BridgeWorkerInfo   *BridgeWorkerInfo   `json:"BridgeWorkerInfo,omitempty"`
	FunctionWorkerInfo *FunctionWorkerInfo `json:"FunctionWorkerInfo,omitempty"`
}

// BulkDeleteSpacesParams defines parameters for BulkDeleteSpaces.
type BulkDeleteSpacesParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Space include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Space are OrganizationID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkPatchSpacesApplicationMergePatchPlusJSONBody defines parameters for BulkPatchSpaces.
type BulkPatchSpacesApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchSpacesParams defines parameters for BulkPatchSpaces.
type BulkPatchSpacesParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Space include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Space are OrganizationID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkCreateSpacesApplicationMergePatchPlusJSONBody defines parameters for BulkCreateSpaces.
type BulkCreateSpacesApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkCreateSpacesParams defines parameters for BulkCreateSpaces.
type BulkCreateSpacesParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Space include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Space are OrganizationID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// NamePrefixes Comma-separated list of prefixes to apply to cloned Space names
	NamePrefixes *string `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`
}

// BulkDeleteBridgeWorkersParams defines parameters for BulkDeleteBridgeWorkers.
type BulkDeleteBridgeWorkersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt, UserID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for BridgeWorker include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for BridgeWorker are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, BridgeWorkerID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// ListAllBridgeWorkersParams defines parameters for ListAllBridgeWorkers.
type ListAllBridgeWorkersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt, UserID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for BridgeWorker include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for BridgeWorker are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, BridgeWorkerID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`

	// Summary Include summary information in the response
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// BulkPatchBridgeWorkersApplicationMergePatchPlusJSONBody defines parameters for BulkPatchBridgeWorkers.
type BulkPatchBridgeWorkersApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations    *map[string]*string `json:"Annotations"`
	BridgeWorkerID *[]int              `json:"BridgeWorkerID"`
	Condition      *string             `json:"Condition"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchBridgeWorkersParams defines parameters for BulkPatchBridgeWorkers.
type BulkPatchBridgeWorkersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt, UserID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for BridgeWorker include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for BridgeWorker are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkDeleteChangeSetsParams defines parameters for BulkDeleteChangeSets.
type BulkDeleteChangeSetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, Description, DisplayName, EndTagID, FilterID, Labels, OrganizationID, Slug, SpaceID, StartTagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for ChangeSet are EndTagID, FilterID, OrganizationID, SpaceID, StartTagID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllChangeSetsParams defines parameters for ListAllChangeSets.
type ListAllChangeSetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, Description, DisplayName, EndTagID, FilterID, Labels, OrganizationID, Slug, SpaceID, StartTagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for ChangeSet are EndTagID, FilterID, OrganizationID, SpaceID, StartTagID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, ChangeSetID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// BulkPatchChangeSetsApplicationMergePatchPlusJSONBody defines parameters for BulkPatchChangeSets.
type BulkPatchChangeSetsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`
	ChangeSetID *[]int              `json:"ChangeSetID"`
	Description *string             `json:"Description"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	EndTagID    *[]int  `json:"EndTagID"`
	FilterID    *[]int  `json:"FilterID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug       *string `json:"Slug"`
	StartTagID *[]int  `json:"StartTagID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchChangeSetsParams defines parameters for BulkPatchChangeSets.
type BulkPatchChangeSetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, Description, DisplayName, EndTagID, FilterID, Labels, OrganizationID, Slug, SpaceID, StartTagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for ChangeSet are EndTagID, FilterID, OrganizationID, SpaceID, StartTagID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkCreateChangeSetsApplicationMergePatchPlusJSONBody defines parameters for BulkCreateChangeSets.
type BulkCreateChangeSetsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`
	ChangeSetID *[]int              `json:"ChangeSetID"`
	Description *string             `json:"Description"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	EndTagID    *[]int  `json:"EndTagID"`
	FilterID    *[]int  `json:"FilterID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug       *string `json:"Slug"`
	StartTagID *[]int  `json:"StartTagID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkCreateChangeSetsParams defines parameters for BulkCreateChangeSets.
type BulkCreateChangeSetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, Description, DisplayName, EndTagID, FilterID, Labels, OrganizationID, Slug, SpaceID, StartTagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for ChangeSet are EndTagID, FilterID, OrganizationID, SpaceID, StartTagID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// NamePrefixes Comma-separated list of prefixes to apply to cloned ChangeSet names
	NamePrefixes *string `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// WhereSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select destination spaces for cloning changesets
	//
	// The whole string must be query-encoded.
	WhereSpace *string `form:"where_space,omitempty" json:"where_space,omitempty"`
}

// BulkDeleteFiltersParams defines parameters for BulkDeleteFilters.
type BulkDeleteFiltersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Filter: CreatedAt, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Filter include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllFiltersParams defines parameters for ListAllFilters.
type ListAllFiltersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Filter: CreatedAt, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Filter include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, FilterID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// BulkPatchFiltersApplicationMergePatchPlusJSONBody defines parameters for BulkPatchFilters.
type BulkPatchFiltersApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FilterID    *[]int  `json:"FilterID"`
	From        *string `json:"From"`
	FromSpaceID *[]int  `json:"FromSpaceID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels       *map[string]*string `json:"Labels"`
	ResourceType *string             `json:"ResourceType"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version   *int    `json:"Version"`
	Where     *string `json:"Where"`
	WhereData *string `json:"WhereData"`
}

// BulkPatchFiltersParams defines parameters for BulkPatchFilters.
type BulkPatchFiltersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Filter: CreatedAt, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Filter include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkCreateFiltersApplicationMergePatchPlusJSONBody defines parameters for BulkCreateFilters.
type BulkCreateFiltersApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FilterID    *[]int  `json:"FilterID"`
	From        *string `json:"From"`
	FromSpaceID *[]int  `json:"FromSpaceID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels       *map[string]*string `json:"Labels"`
	ResourceType *string             `json:"ResourceType"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version   *int    `json:"Version"`
	Where     *string `json:"Where"`
	WhereData *string `json:"WhereData"`
}

// BulkCreateFiltersParams defines parameters for BulkCreateFilters.
type BulkCreateFiltersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Filter: CreatedAt, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Filter include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// NamePrefixes Comma-separated list of prefixes to apply to cloned Filter names
	NamePrefixes *string `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// WhereSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select destination spaces for cloning filters
	//
	// The whole string must be query-encoded.
	WhereSpace *string `form:"where_space,omitempty" json:"where_space,omitempty"`
}

// InvokeFunctionsOnOrgParams defines parameters for InvokeFunctionsOnOrg.
type InvokeFunctionsOnOrgParams struct {
	// DryRun Dry run mode: when true, skip updating configuration data even if it changed
	DryRun *string `form:"dry_run,omitempty" json:"dry_run,omitempty"`

	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`
}

// BulkDeleteInvocationsParams defines parameters for BulkDeleteInvocations.
type BulkDeleteInvocationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Invocation include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllInvocationsParams defines parameters for ListAllInvocations.
type ListAllInvocationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Invocation include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, InvocationID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// BulkPatchInvocationsApplicationMergePatchPlusJSONBody defines parameters for BulkPatchInvocations.
type BulkPatchInvocationsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Arguments Function arguments
	Arguments      *[]map[string]interface{} `json:"Arguments"`
	BridgeWorkerID *[]int                    `json:"BridgeWorkerID"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// FunctionName Function name
	FunctionName *string `json:"FunctionName"`
	InvocationID *[]int  `json:"InvocationID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug          *string `json:"Slug"`
	ToolchainType *string `json:"ToolchainType"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchInvocationsParams defines parameters for BulkPatchInvocations.
type BulkPatchInvocationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Invocation include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkCreateInvocationsApplicationMergePatchPlusJSONBody defines parameters for BulkCreateInvocations.
type BulkCreateInvocationsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Arguments Function arguments
	Arguments      *[]map[string]interface{} `json:"Arguments"`
	BridgeWorkerID *[]int                    `json:"BridgeWorkerID"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// FunctionName Function name
	FunctionName *string `json:"FunctionName"`
	InvocationID *[]int  `json:"InvocationID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug          *string `json:"Slug"`
	ToolchainType *string `json:"ToolchainType"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkCreateInvocationsParams defines parameters for BulkCreateInvocations.
type BulkCreateInvocationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Invocation include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// NamePrefixes Comma-separated list of prefixes to apply to cloned Invocation names
	NamePrefixes *string `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// WhereSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select destination spaces for cloning invocations
	//
	// The whole string must be query-encoded.
	WhereSpace *string `form:"where_space,omitempty" json:"where_space,omitempty"`
}

// BulkDeleteLinksParams defines parameters for BulkDeleteLinks.
type BulkDeleteLinksParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Link: CreatedAt, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.
	//
	// filter
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Link include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// SearchListLinksParams defines parameters for SearchListLinks.
type SearchListLinksParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Link: CreatedAt, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Link include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, LinkID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// BulkPatchLinksApplicationMergePatchPlusJSONBody defines parameters for BulkPatchLinks.
type BulkPatchLinksApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FromUnitID  *[]int  `json:"FromUnitID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`
	LinkID *[]int              `json:"LinkID"`

	// Slug Unique URL-safe identifier for the entity.
	Slug      *string `json:"Slug"`
	ToSpaceID *[]int  `json:"ToSpaceID"`
	ToUnitID  *[]int  `json:"ToUnitID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchLinksParams defines parameters for BulkPatchLinks.
type BulkPatchLinksParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Link: CreatedAt, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.
	//
	// filter
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Link include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkCreateLinksApplicationMergePatchPlusJSONBody defines parameters for BulkCreateLinks.
type BulkCreateLinksApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FromUnitID  *[]int  `json:"FromUnitID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`
	LinkID *[]int              `json:"LinkID"`

	// Slug Unique URL-safe identifier for the entity.
	Slug      *string `json:"Slug"`
	ToSpaceID *[]int  `json:"ToSpaceID"`
	ToUnitID  *[]int  `json:"ToUnitID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkCreateLinksParams defines parameters for BulkCreateLinks.
type BulkCreateLinksParams struct {
	// WhereSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select destination spaces for created links
	//
	// The whole string must be query-encoded.
	WhereSpace *string `form:"where_space,omitempty" json:"where_space,omitempty"`

	// WhereToSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select ToSpaces for created links
	//
	// The whole string must be query-encoded.
	WhereToSpace *string `form:"where_to_space,omitempty" json:"where_to_space,omitempty"`

	// WhereFrom The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Where expression to select FromUnits for created links
	//
	// The whole string must be query-encoded.
	WhereFrom *string `form:"where_from,omitempty" json:"where_from,omitempty"`

	// WhereTo The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Where expression to select ToUnits for created links
	//
	// The whole string must be query-encoded.
	WhereTo *string `form:"where_to,omitempty" json:"where_to,omitempty"`
}

// ListOrganizationsParams defines parameters for ListOrganizations.
type ListOrganizationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Organization: BillingAccountID, CreatedAt, DisplayName, ExternalID, Labels, OrganizationID, Slug, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Organization include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Organization.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Organization are .
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Organization.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, OrganizationID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetOrganizationParams defines parameters for GetOrganization.
type GetOrganizationParams struct {
	// Include Include clause for expanding related entities in the response for Organization.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Organization are .
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Organization.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, OrganizationID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// ListOrganizationMembersParams defines parameters for ListOrganizationMembers.
type ListOrganizationMembersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on OrganizationMember: DisplayName, ExternalID, Slug, UserID, Username.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for OrganizationMember include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`
}

// ListSpacesParams defines parameters for ListSpaces.
type ListSpacesParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Space include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Space are OrganizationID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, SpaceID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`

	// Summary Flag parameter for enabling summary
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// GetSpaceParams defines parameters for GetSpace.
type GetSpaceParams struct {
	// Include Include clause for expanding related entities in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Space are OrganizationID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Space.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, SpaceID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`

	// Summary Flag parameter for enabling summary
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// PatchSpaceApplicationMergePatchPlusJSONBody defines parameters for PatchSpace.
type PatchSpaceApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// ListBridgeWorkersParams defines parameters for ListBridgeWorkers.
type ListBridgeWorkersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt, UserID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for BridgeWorker include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for BridgeWorker are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, BridgeWorkerID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetBridgeWorkerParams defines parameters for GetBridgeWorker.
type GetBridgeWorkerParams struct {
	// Include Include clause for expanding related entities in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for BridgeWorker are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for BridgeWorker.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, BridgeWorkerID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchBridgeWorkerApplicationMergePatchPlusJSONBody defines parameters for PatchBridgeWorker.
type PatchBridgeWorkerApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations    *map[string]*string `json:"Annotations"`
	BridgeWorkerID *[]int              `json:"BridgeWorkerID"`
	Condition      *string             `json:"Condition"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// ListChangeSetsParams defines parameters for ListChangeSets.
type ListChangeSetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on ChangeSet: ChangeSetID, CreatedAt, Description, DisplayName, EndTagID, FilterID, Labels, OrganizationID, Slug, SpaceID, StartTagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for ChangeSet include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for ChangeSet are EndTagID, FilterID, OrganizationID, SpaceID, StartTagID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, ChangeSetID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetChangeSetParams defines parameters for GetChangeSet.
type GetChangeSetParams struct {
	// Include Include clause for expanding related entities in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for ChangeSet are EndTagID, FilterID, OrganizationID, SpaceID, StartTagID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for ChangeSet.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, ChangeSetID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchChangeSetApplicationMergePatchPlusJSONBody defines parameters for PatchChangeSet.
type PatchChangeSetApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`
	ChangeSetID *[]int              `json:"ChangeSetID"`
	Description *string             `json:"Description"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	EndTagID    *[]int  `json:"EndTagID"`
	FilterID    *[]int  `json:"FilterID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug       *string `json:"Slug"`
	StartTagID *[]int  `json:"StartTagID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// ListFiltersParams defines parameters for ListFilters.
type ListFiltersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Filter: CreatedAt, DisplayName, FilterID, From, FromSpaceID, Labels, OrganizationID, ResourceType, Slug, SpaceID, UpdatedAt, Where, WhereData.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Filter include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, FilterID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetFilterParams defines parameters for GetFilter.
type GetFilterParams struct {
	// Include Include clause for expanding related entities in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Filter are FromSpaceID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Filter.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, FilterID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchFilterApplicationMergePatchPlusJSONBody defines parameters for PatchFilter.
type PatchFilterApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FilterID    *[]int  `json:"FilterID"`
	From        *string `json:"From"`
	FromSpaceID *[]int  `json:"FromSpaceID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels       *map[string]*string `json:"Labels"`
	ResourceType *string             `json:"ResourceType"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version   *int    `json:"Version"`
	Where     *string `json:"Where"`
	WhereData *string `json:"WhereData"`
}

// ListFunctionsParams defines parameters for ListFunctions.
type ListFunctionsParams struct {
	// Entity Type of entity used to identify the worker whose functions should be listed: unit, target, or worker
	Entity *string `form:"entity,omitempty" json:"entity,omitempty"`

	// Id ID of the entity used to identify the worker whose functions should be listed
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// InvokeFunctionsParams defines parameters for InvokeFunctions.
type InvokeFunctionsParams struct {
	// UnitId Unit ID of the Revision to invoke functions on
	UnitId *openapi_types.UUID `form:"unit_id,omitempty" json:"unit_id,omitempty"`

	// RevisionId Revision ID to invoke functions on instead of units
	RevisionId *openapi_types.UUID `form:"revision_id,omitempty" json:"revision_id,omitempty"`

	// DryRun Dry run mode: when true, skip updating configuration data even if it changed
	DryRun *string `form:"dry_run,omitempty" json:"dry_run,omitempty"`

	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`
}

// ListInvocationsParams defines parameters for ListInvocations.
type ListInvocationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Invocation: BridgeWorkerID, CreatedAt, DisplayName, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Invocation include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, InvocationID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetInvocationParams defines parameters for GetInvocation.
type GetInvocationParams struct {
	// Include Include clause for expanding related entities in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Invocation are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Invocation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, InvocationID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchInvocationApplicationMergePatchPlusJSONBody defines parameters for PatchInvocation.
type PatchInvocationApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Arguments Function arguments
	Arguments      *[]map[string]interface{} `json:"Arguments"`
	BridgeWorkerID *[]int                    `json:"BridgeWorkerID"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// FunctionName Function name
	FunctionName *string `json:"FunctionName"`
	InvocationID *[]int  `json:"InvocationID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug          *string `json:"Slug"`
	ToolchainType *string `json:"ToolchainType"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// ListLinksParams defines parameters for ListLinks.
type ListLinksParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Link: CreatedAt, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Link include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, LinkID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetLinkParams defines parameters for GetLink.
type GetLinkParams struct {
	// Include Include clause for expanding related entities in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Link.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, LinkID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchLinkApplicationMergePatchPlusJSONBody defines parameters for PatchLink.
type PatchLinkApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FromUnitID  *[]int  `json:"FromUnitID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`
	LinkID *[]int              `json:"LinkID"`

	// Slug Unique URL-safe identifier for the entity.
	Slug      *string `json:"Slug"`
	ToSpaceID *[]int  `json:"ToSpaceID"`
	ToUnitID  *[]int  `json:"ToUnitID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// ListSetsParams defines parameters for ListSets.
type ListSetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Set: CreatedAt, DisplayName, Labels, OrganizationID, SetID, Slug, SpaceID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Set include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Set.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Set are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Set.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, SetID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetSetParams defines parameters for GetSet.
type GetSetParams struct {
	// Include Include clause for expanding related entities in the response for Set.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Set are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Set.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, SetID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Tag: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Tag include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Tag are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TagID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetTagParams defines parameters for GetTag.
type GetTagParams struct {
	// Include Include clause for expanding related entities in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Tag are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TagID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchTagApplicationMergePatchPlusJSONBody defines parameters for PatchTag.
type PatchTagApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug  *string `json:"Slug"`
	TagID *[]int  `json:"TagID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// ListTargetsParams defines parameters for ListTargets.
type ListTargetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Target include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TargetID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetTargetParams defines parameters for GetTarget.
type GetTargetParams struct {
	// Include Include clause for expanding related entities in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TargetID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchTargetApplicationMergePatchPlusJSONBody defines parameters for PatchTarget.
type PatchTargetApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations    *map[string]*string `json:"Annotations"`
	BridgeWorkerID *[]int              `json:"BridgeWorkerID"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels       *map[string]*string `json:"Labels"`
	Parameters   *string             `json:"Parameters"`
	ProviderType *string             `json:"ProviderType"`

	// Slug Unique URL-safe identifier for the entity.
	Slug          *string `json:"Slug"`
	TargetID      *[]int  `json:"TargetID"`
	ToolchainType *string `json:"ToolchainType"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// ListTriggersParams defines parameters for ListTriggers.
type ListTriggersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Trigger include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TriggerID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetTriggerParams defines parameters for GetTrigger.
type GetTriggerParams struct {
	// Include Include clause for expanding related entities in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TriggerID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchTriggerApplicationMergePatchPlusJSONBody defines parameters for PatchTrigger.
type PatchTriggerApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Arguments Function arguments
	Arguments      *[]map[string]interface{} `json:"Arguments"`
	BridgeWorkerID *[]int                    `json:"BridgeWorkerID"`
	Disabled       *bool                     `json:"Disabled"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	Enforced    *bool   `json:"Enforced"`
	Event       *string `json:"Event"`

	// FunctionName Function name
	FunctionName *string `json:"FunctionName"`
	InvocationID *[]int  `json:"InvocationID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug          *string `json:"Slug"`
	ToolchainType *string `json:"ToolchainType"`
	TriggerID     *[]int  `json:"TriggerID"`
	Validating    *bool   `json:"Validating"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// ListUnitsParams defines parameters for ListUnits.
type ListUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, UnitID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// CreateUnitParams defines parameters for CreateUnit.
type CreateUnitParams struct {
	// UpstreamSpaceId Unique identifier for a upstream_space_id
	UpstreamSpaceId *openapi_types.UUID `form:"upstream_space_id,omitempty" json:"upstream_space_id,omitempty"`

	// UpstreamUnitId Unique identifier for a upstream_unit_id
	UpstreamUnitId *openapi_types.UUID `form:"upstream_unit_id,omitempty" json:"upstream_unit_id,omitempty"`
}

// ListExtendedUnitsParams defines parameters for ListExtendedUnits.
type ListExtendedUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, UnitID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetUnitParams defines parameters for GetUnit.
type GetUnitParams struct {
	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, UnitID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchUnitApplicationMergePatchPlusJSONBody defines parameters for PatchUnit.
type PatchUnitApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Data The full configuration data for this unit.
	Data *[]int `json:"Data"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// LastChangeDescription LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.
	LastChangeDescription *string `json:"LastChangeDescription"`

	// SetID Unique identifier for the Set the Unit belongs to. Sets are used to group related units together. Optional. Units are not required to belong to sets. Cleared automatically when the Set is deleted.
	SetID *[]int `json:"SetID"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// TargetID TargetID is the identifier of the target this unit is associated with. This defines where the configuration will be applied. It must be set to a valid Target within the same Space before the Unit can be Applied, Destroyed, Imported, or Refreshed.
	TargetID *[]int `json:"TargetID"`

	// ToolchainType ToolchainType specifies the type of toolchain for this unit. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
	ToolchainType *string `json:"ToolchainType"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// PatchUnitParams defines parameters for PatchUnit.
type PatchUnitParams struct {
	// RevisionId Unique identifier for a revision_id
	RevisionId *openapi_types.UUID `form:"revision_id,omitempty" json:"revision_id,omitempty"`

	// Upgrade Flag parameter for enabling upgrade
	Upgrade *bool `form:"upgrade,omitempty" json:"upgrade,omitempty"`

	// Restore Restore mode: 'LiveRevisionNum', 'LastAppliedRevisionNum', or 'PreviousLiveRevisionNum'
	Restore *string `form:"restore,omitempty" json:"restore,omitempty"`
}

// UpdateUnitParams defines parameters for UpdateUnit.
type UpdateUnitParams struct {
	// RevisionId Unique identifier for a revision_id
	RevisionId *openapi_types.UUID `form:"revision_id,omitempty" json:"revision_id,omitempty"`

	// Upgrade Flag parameter for enabling upgrade
	Upgrade *bool `form:"upgrade,omitempty" json:"upgrade,omitempty"`

	// Restore Restore mode: 'LiveRevisionNum', 'LastAppliedRevisionNum', or 'PreviousLiveRevisionNum'
	Restore *string `form:"restore,omitempty" json:"restore,omitempty"`
}

// ListExtendedMutationsParams defines parameters for ListExtendedMutations.
type ListExtendedMutationsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Mutation: CreatedAt, FunctionName, InvocationID, LinkID, MutationID, MutationNum, OrganizationID, RestoredRevisionNum, RevisionID, RevisionNum, SpaceID, TriggerID, UnitID, UpdatedAt, UpgradedFromUpstreamRevisionNum.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Mutation include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Mutation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Mutation are InvocationID, LinkID, OrganizationID, RevisionID, SpaceID, TriggerID, UnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Mutation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, MutationID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetExtendedMutationParams defines parameters for GetExtendedMutation.
type GetExtendedMutationParams struct {
	// Include Include clause for expanding related entities in the response for Mutation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Mutation are InvocationID, LinkID, OrganizationID, RevisionID, SpaceID, TriggerID, UnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Mutation.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, MutationID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// ListExtendedRevisionsParams defines parameters for ListExtendedRevisions.
type ListExtendedRevisionsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Revision: ApplyGates, ApprovedBy, CreatedAt, Description, LiveAt, OrganizationID, RevisionID, RevisionNum, Source, SpaceID, UnitID, UpdatedAt, UserAgent, UserID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Revision include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Revision.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Revision are OrganizationID, SpaceID, UnitID, UserID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Revision.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, RevisionID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetExtendedRevisionParams defines parameters for GetExtendedRevision.
type GetExtendedRevisionParams struct {
	// Include Include clause for expanding related entities in the response for Revision.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Revision are OrganizationID, SpaceID, UnitID, UserID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Revision.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, RevisionID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// ListUnitEventsParams defines parameters for ListUnitEvents.
type ListUnitEventsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on UnitEvent: Action, BridgeWorkerID, CreatedAt, OrganizationID, QueuedOperationID, Result, RevisionNum, SpaceID, StartedAt, Status, TerminatedAt, UnitEventID, UnitID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for UnitEvent include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`
}

// ListViewsParams defines parameters for ListViews.
type ListViewsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for View include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for View are FilterID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, ViewID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// GetViewParams defines parameters for GetView.
type GetViewParams struct {
	// Include Include clause for expanding related entities in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for View are FilterID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, ViewID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// PatchViewApplicationMergePatchPlusJSONBody defines parameters for PatchView.
type PatchViewApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string       `json:"Annotations"`
	Columns     *[]map[string]interface{} `json:"Columns"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FilterID    *[]int  `json:"FilterID"`
	GroupBy     *string `json:"GroupBy"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels           *map[string]*string `json:"Labels"`
	OrderBy          *string             `json:"OrderBy"`
	OrderByDirection *string             `json:"OrderByDirection"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int   `json:"Version"`
	ViewID  *[]int `json:"ViewID"`
}

// BulkDeleteTagsParams defines parameters for BulkDeleteTags.
type BulkDeleteTagsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Tag: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Tag include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Tag are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllTagsParams defines parameters for ListAllTags.
type ListAllTagsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Tag: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Tag include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Tag are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TagID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// BulkPatchTagsApplicationMergePatchPlusJSONBody defines parameters for BulkPatchTags.
type BulkPatchTagsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug  *string `json:"Slug"`
	TagID *[]int  `json:"TagID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchTagsParams defines parameters for BulkPatchTags.
type BulkPatchTagsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Tag: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Tag include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Tag are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkCreateTagsApplicationMergePatchPlusJSONBody defines parameters for BulkCreateTags.
type BulkCreateTagsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug  *string `json:"Slug"`
	TagID *[]int  `json:"TagID"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkCreateTagsParams defines parameters for BulkCreateTags.
type BulkCreateTagsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Tag: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, TagID, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Tag include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Tag.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Tag are OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// NamePrefixes Comma-separated list of prefixes to apply to cloned Tag names
	NamePrefixes *string `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// WhereSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select destination spaces for cloning tags
	//
	// The whole string must be query-encoded.
	WhereSpace *string `form:"where_space,omitempty" json:"where_space,omitempty"`
}

// BulkDeleteTargetsParams defines parameters for BulkDeleteTargets.
type BulkDeleteTargetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Target include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllTargetsParams defines parameters for ListAllTargets.
type ListAllTargetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Target include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TargetID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// BulkPatchTargetsApplicationMergePatchPlusJSONBody defines parameters for BulkPatchTargets.
type BulkPatchTargetsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations    *map[string]*string `json:"Annotations"`
	BridgeWorkerID *[]int              `json:"BridgeWorkerID"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels       *map[string]*string `json:"Labels"`
	Parameters   *string             `json:"Parameters"`
	ProviderType *string             `json:"ProviderType"`

	// Slug Unique URL-safe identifier for the entity.
	Slug          *string `json:"Slug"`
	TargetID      *[]int  `json:"TargetID"`
	ToolchainType *string `json:"ToolchainType"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchTargetsParams defines parameters for BulkPatchTargets.
type BulkPatchTargetsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Target include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Target.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkDeleteTriggersParams defines parameters for BulkDeleteTriggers.
type BulkDeleteTriggersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Trigger include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllTriggersParams defines parameters for ListAllTriggers.
type ListAllTriggersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Trigger include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, TriggerID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// BulkPatchTriggersApplicationMergePatchPlusJSONBody defines parameters for BulkPatchTriggers.
type BulkPatchTriggersApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Arguments Function arguments
	Arguments      *[]map[string]interface{} `json:"Arguments"`
	BridgeWorkerID *[]int                    `json:"BridgeWorkerID"`
	Disabled       *bool                     `json:"Disabled"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	Enforced    *bool   `json:"Enforced"`
	Event       *string `json:"Event"`

	// FunctionName Function name
	FunctionName *string `json:"FunctionName"`
	InvocationID *[]int  `json:"InvocationID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug          *string `json:"Slug"`
	ToolchainType *string `json:"ToolchainType"`
	TriggerID     *[]int  `json:"TriggerID"`
	Validating    *bool   `json:"Validating"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchTriggersParams defines parameters for BulkPatchTriggers.
type BulkPatchTriggersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Trigger include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkCreateTriggersApplicationMergePatchPlusJSONBody defines parameters for BulkCreateTriggers.
type BulkCreateTriggersApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Arguments Function arguments
	Arguments      *[]map[string]interface{} `json:"Arguments"`
	BridgeWorkerID *[]int                    `json:"BridgeWorkerID"`
	Disabled       *bool                     `json:"Disabled"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	Enforced    *bool   `json:"Enforced"`
	Event       *string `json:"Event"`

	// FunctionName Function name
	FunctionName *string `json:"FunctionName"`
	InvocationID *[]int  `json:"InvocationID"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// Slug Unique URL-safe identifier for the entity.
	Slug          *string `json:"Slug"`
	ToolchainType *string `json:"ToolchainType"`
	TriggerID     *[]int  `json:"TriggerID"`
	Validating    *bool   `json:"Validating"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkCreateTriggersParams defines parameters for BulkCreateTriggers.
type BulkCreateTriggersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, Disabled, DisplayName, Enforced, Event, FunctionName, InvocationID, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Trigger include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Trigger.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Trigger are BridgeWorkerID, InvocationID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// NamePrefixes Comma-separated list of prefixes to apply to cloned Trigger names
	NamePrefixes *string `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// WhereSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select destination spaces for cloning triggers
	//
	// The whole string must be query-encoded.
	WhereSpace *string `form:"where_space,omitempty" json:"where_space,omitempty"`
}

// BulkDeleteUnitsParams defines parameters for BulkDeleteUnits.
type BulkDeleteUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllUnitsParams defines parameters for ListAllUnits.
type ListAllUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, UnitID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`

	// ResourceType Resource type: Resource type to match for the desired ToolchainType, for example apps/v1/Deployment
	ResourceType *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`

	// WhereData Where data: The specified string is an expression for the purpose of evaluating whether the configuration data matches the filter. It supports conjunctions using `AND` of relational expressions of the form *path* *operator* *literal*. The path specifications are dot-separated, for both map fields and array indices, as in `spec.template.spec.containers.0.image = 'ghcr.io/headlamp-k8s/headlamp:latest' AND spec.replicas > 1`. Path expressions support `*` for wildcard array or map segments and `?key=value` syntax for associative matches of array elements containing objects with a `key` attribute. Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `!~`, `~*`, `!~*`, `IN`, `NOT IN`. String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards, `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE. String regex operators: `~` for regex matching, `~*` for case-insensitive regex, `!~` and `!~*` for regex not matching (case-sensitive and insensitive). Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`. Boolean values support equality and inequality only. The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses, such as `spec.template.spec.containers.0.image#reference IN (':latest', ':arm64-latest')`. The syntax `.|` requires the preceding path to exist; otherwise the relation `!=` will always return true regardless what it is compared with. String literals are quoted with single quotes, such as `'string'`. Integer and boolean literals are also supported for attributes of those types. The whole string must be query-encoded.
	WhereData *string `form:"where_data,omitempty" json:"where_data,omitempty"`
}

// BulkPatchUnitsApplicationMergePatchPlusJSONBody defines parameters for BulkPatchUnits.
type BulkPatchUnitsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Data The full configuration data for this unit.
	Data *[]int `json:"Data"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// LastChangeDescription LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.
	LastChangeDescription *string `json:"LastChangeDescription"`

	// SetID Unique identifier for the Set the Unit belongs to. Sets are used to group related units together. Optional. Units are not required to belong to sets. Cleared automatically when the Set is deleted.
	SetID *[]int `json:"SetID"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// TargetID TargetID is the identifier of the target this unit is associated with. This defines where the configuration will be applied. It must be set to a valid Target within the same Space before the Unit can be Applied, Destroyed, Imported, or Refreshed.
	TargetID *[]int `json:"TargetID"`

	// ToolchainType ToolchainType specifies the type of toolchain for this unit. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
	ToolchainType *string `json:"ToolchainType"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkPatchUnitsParams defines parameters for BulkPatchUnits.
type BulkPatchUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Upgrade If true, upgrade units from upstream sources
	Upgrade *bool `form:"upgrade,omitempty" json:"upgrade,omitempty"`

	// Restore Restore mode: 'LiveRevisionNum', 'LastAppliedRevisionNum', or 'PreviousLiveRevisionNum'
	Restore *string `form:"restore,omitempty" json:"restore,omitempty"`
}

// BulkCreateUnitsApplicationMergePatchPlusJSONBody defines parameters for BulkCreateUnits.
type BulkCreateUnitsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string `json:"Annotations"`

	// Data The full configuration data for this unit.
	Data *[]int `json:"Data"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels *map[string]*string `json:"Labels"`

	// LastChangeDescription LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.
	LastChangeDescription *string `json:"LastChangeDescription"`

	// SetID Unique identifier for the Set the Unit belongs to. Sets are used to group related units together. Optional. Units are not required to belong to sets. Cleared automatically when the Set is deleted.
	SetID *[]int `json:"SetID"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// TargetID TargetID is the identifier of the target this unit is associated with. This defines where the configuration will be applied. It must be set to a valid Target within the same Space before the Unit can be Applied, Destroyed, Imported, or Refreshed.
	TargetID *[]int `json:"TargetID"`

	// ToolchainType ToolchainType specifies the type of toolchain for this unit. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
	ToolchainType *string `json:"ToolchainType"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int `json:"Version"`
}

// BulkCreateUnitsParams defines parameters for BulkCreateUnits.
type BulkCreateUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// NamePrefixes Comma-separated list of prefixes to apply to cloned Unit names
	NamePrefixes *string `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// WhereSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select destination spaces for cloning units
	//
	// The whole string must be query-encoded.
	WhereSpace *string `form:"where_space,omitempty" json:"where_space,omitempty"`
}

// BulkApplyUnitsParams defines parameters for BulkApplyUnits.
type BulkApplyUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where string `form:"where" json:"where"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// DryRun Dry run mode - validates which units would be applied without executing
	DryRun *bool `form:"dry_run,omitempty" json:"dry_run,omitempty"`
}

// BulkApproveUnitsParams defines parameters for BulkApproveUnits.
type BulkApproveUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkTagUnitsParams defines parameters for BulkTagUnits.
type BulkTagUnitsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
	//
	// Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for Unit include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for Unit.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on User: CreatedAt, DisplayName, ExternalID, Slug, UpdatedAt, UserID, Username.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for User include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`
}

// BulkDeleteViewsParams defines parameters for BulkDeleteViews.
type BulkDeleteViewsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for View include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for View are FilterID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// ListAllViewsParams defines parameters for ListAllViews.
type ListAllViewsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for View include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for View are FilterID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// Select Select clause for specifying which fields to include in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	// If not specified, all fields are returned.
	// Entity and parent IDs (like OrganizationID, SpaceID, ViewID) and Slug are always returned regardless of the select parameter.
	// Fields used in where and contains filters are also automatically included.
	// Example: 'DisplayName,CreatedAt,Labels' will return only those fields plus the required ID and Slug fields.
	// The whole string must be query-encoded.
	Select *string `form:"select,omitempty" json:"select,omitempty"`
}

// BulkPatchViewsApplicationMergePatchPlusJSONBody defines parameters for BulkPatchViews.
type BulkPatchViewsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string       `json:"Annotations"`
	Columns     *[]map[string]interface{} `json:"Columns"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FilterID    *[]int  `json:"FilterID"`
	GroupBy     *string `json:"GroupBy"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels           *map[string]*string `json:"Labels"`
	OrderBy          *string             `json:"OrderBy"`
	OrderByDirection *string             `json:"OrderByDirection"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int   `json:"Version"`
	ViewID  *[]int `json:"ViewID"`
}

// BulkPatchViewsParams defines parameters for BulkPatchViews.
type BulkPatchViewsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for View include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for View are FilterID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`
}

// BulkCreateViewsApplicationMergePatchPlusJSONBody defines parameters for BulkCreateViews.
type BulkCreateViewsApplicationMergePatchPlusJSONBody struct {
	// Annotations An optional map of Annotation key/value pairs for tools to attach information to entities.
	Annotations *map[string]*string       `json:"Annotations"`
	Columns     *[]map[string]interface{} `json:"Columns"`

	// DisplayName Friendly name for the entity.
	DisplayName *string `json:"DisplayName"`
	FilterID    *[]int  `json:"FilterID"`
	GroupBy     *string `json:"GroupBy"`

	// Labels An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
	Labels           *map[string]*string `json:"Labels"`
	OrderBy          *string             `json:"OrderBy"`
	OrderByDirection *string             `json:"OrderByDirection"`

	// Slug Unique URL-safe identifier for the entity.
	Slug *string `json:"Slug"`

	// Version An entity-specific sequence number used for optimistic concurrency control. The value read must be sent in calls to Update.
	Version *int   `json:"Version"`
	ViewID  *[]int `json:"ViewID"`
}

// BulkCreateViewsParams defines parameters for BulkCreateViews.
type BulkCreateViewsParams struct {
	// Where The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on View: CreatedAt, DisplayName, FilterID, GroupBy, Labels, OrderBy, OrderByDirection, OrganizationID, Slug, SpaceID, UpdatedAt, ViewID.
	//
	// The whole string must be query-encoded.
	Where *string `form:"where,omitempty" json:"where,omitempty"`

	// Contains Free text search that approximately matches the specified string against string fields and map keys/values.
	//
	// The search is case-insensitive and uses pattern matching to find entities containing the text.
	//
	// Searchable string fields include attributes like Slug, DisplayName, and string-typed custom fields.
	//
	// For map fields (like Labels and Annotations), the search matches both map keys and values.
	//
	// The search uses OR logic across all searchable fields, so matching any field will return the entity.
	//
	// If both 'where' and 'contains' parameters are specified, they are combined with AND logic.
	//
	// Searchable fields for View include string and map-type attributes from the queryable attributes list.
	//
	// The whole string must be query-encoded.
	Contains *string `form:"contains,omitempty" json:"contains,omitempty"`

	// Include Include clause for expanding related entities in the response for View.
	// The attribute names are case-sensitive, PascalCase, and
	// expected in a comma-separated list format as in the JSON encoding.
	//
	// Supported attributes for View are FilterID, OrganizationID, SpaceID.
	//
	// The whole string must be query-encoded.
	Include *string `form:"include,omitempty" json:"include,omitempty"`

	// NamePrefixes Comma-separated list of prefixes to apply to cloned View names
	NamePrefixes *string `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// WhereSpace The specified string is an expression for the purpose of filtering
	// the list of Units returned. The expression syntax was inspired by SQL.
	// It supports conjunctions using `AND` of relational expressions of the form *attribute*
	// *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
	// as in the JSON encoding.
	// Strings support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `LIKE`, `ILIKE`, `~~`, `!~~`, `~`, `~*`, `!~`, `!~*`, `IN`, `NOT IN`.
	// String pattern operators: `LIKE` and `~~` for pattern matching with `%` and `_` wildcards,
	// `ILIKE` for case-insensitive pattern matching, `!~~` for NOT LIKE.
	// String regex operators: `~` for regex matching, `~*` for case-insensitive regex,
	// `!~` and `!~*` for regex not matching (case-sensitive and insensitive).
	// Integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`, `IN`, `NOT IN`.
	// UUIDs and boolean attributes support equality and inequality only.
	// UUID and time literals must be quoted as string literals.
	// String literals are quoted with single quotes, such as `'string'`.
	// Time literals use the same form as when serialized as JSON,
	// such as: `CreatedAt > '2025-02-18T23:16:34'`.
	// Integer and boolean literals are also supported for attributes of those types.
	// Arrays support the `?` operator to to match any element of the array,
	// as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
	// Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
	// Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
	// The `IN` and `NOT IN` operators accept a comma-separated list of values in parentheses,
	// such as `Slug IN ('slugone', 'slugtwo')` or `Labels.environment IN ('prod', 'staging')`.
	// Conjunctions are supported using the `AND` operator.
	// An example conjunction is:
	// `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
	//
	// Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
	//
	// Where expression to select destination spaces for cloning views
	//
	// The whole string must be query-encoded.
	WhereSpace *string `form:"where_space,omitempty" json:"where_space,omitempty"`
}

// BulkPatchSpacesApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchSpaces for application/merge-patch+json ContentType.
type BulkPatchSpacesApplicationMergePatchPlusJSONRequestBody BulkPatchSpacesApplicationMergePatchPlusJSONBody

// BulkCreateSpacesApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateSpaces for application/merge-patch+json ContentType.
type BulkCreateSpacesApplicationMergePatchPlusJSONRequestBody BulkCreateSpacesApplicationMergePatchPlusJSONBody

// BulkPatchBridgeWorkersApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchBridgeWorkers for application/merge-patch+json ContentType.
type BulkPatchBridgeWorkersApplicationMergePatchPlusJSONRequestBody BulkPatchBridgeWorkersApplicationMergePatchPlusJSONBody

// CreateActionResultJSONRequestBody defines body for CreateActionResult for application/json ContentType.
type CreateActionResultJSONRequestBody = ActionResult

// BulkPatchChangeSetsApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchChangeSets for application/merge-patch+json ContentType.
type BulkPatchChangeSetsApplicationMergePatchPlusJSONRequestBody BulkPatchChangeSetsApplicationMergePatchPlusJSONBody

// BulkCreateChangeSetsApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateChangeSets for application/merge-patch+json ContentType.
type BulkCreateChangeSetsApplicationMergePatchPlusJSONRequestBody BulkCreateChangeSetsApplicationMergePatchPlusJSONBody

// BulkPatchFiltersApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchFilters for application/merge-patch+json ContentType.
type BulkPatchFiltersApplicationMergePatchPlusJSONRequestBody BulkPatchFiltersApplicationMergePatchPlusJSONBody

// BulkCreateFiltersApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateFilters for application/merge-patch+json ContentType.
type BulkCreateFiltersApplicationMergePatchPlusJSONRequestBody BulkCreateFiltersApplicationMergePatchPlusJSONBody

// InvokeFunctionsOnOrgJSONRequestBody defines body for InvokeFunctionsOnOrg for application/json ContentType.
type InvokeFunctionsOnOrgJSONRequestBody = FunctionInvocationsRequest

// BulkPatchInvocationsApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchInvocations for application/merge-patch+json ContentType.
type BulkPatchInvocationsApplicationMergePatchPlusJSONRequestBody BulkPatchInvocationsApplicationMergePatchPlusJSONBody

// BulkCreateInvocationsApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateInvocations for application/merge-patch+json ContentType.
type BulkCreateInvocationsApplicationMergePatchPlusJSONRequestBody BulkCreateInvocationsApplicationMergePatchPlusJSONBody

// BulkPatchLinksApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchLinks for application/merge-patch+json ContentType.
type BulkPatchLinksApplicationMergePatchPlusJSONRequestBody BulkPatchLinksApplicationMergePatchPlusJSONBody

// BulkCreateLinksApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateLinks for application/merge-patch+json ContentType.
type BulkCreateLinksApplicationMergePatchPlusJSONRequestBody BulkCreateLinksApplicationMergePatchPlusJSONBody

// CreateOrganizationJSONRequestBody defines body for CreateOrganization for application/json ContentType.
type CreateOrganizationJSONRequestBody = Organization

// UpdateOrganizationJSONRequestBody defines body for UpdateOrganization for application/json ContentType.
type UpdateOrganizationJSONRequestBody = Organization

// CreateOrganizationMemberJSONRequestBody defines body for CreateOrganizationMember for application/json ContentType.
type CreateOrganizationMemberJSONRequestBody = OrganizationMember

// CreateSpaceJSONRequestBody defines body for CreateSpace for application/json ContentType.
type CreateSpaceJSONRequestBody = Space

// PatchSpaceApplicationMergePatchPlusJSONRequestBody defines body for PatchSpace for application/merge-patch+json ContentType.
type PatchSpaceApplicationMergePatchPlusJSONRequestBody PatchSpaceApplicationMergePatchPlusJSONBody

// UpdateSpaceJSONRequestBody defines body for UpdateSpace for application/json ContentType.
type UpdateSpaceJSONRequestBody = Space

// CreateBridgeWorkerJSONRequestBody defines body for CreateBridgeWorker for application/json ContentType.
type CreateBridgeWorkerJSONRequestBody = BridgeWorker

// PatchBridgeWorkerApplicationMergePatchPlusJSONRequestBody defines body for PatchBridgeWorker for application/merge-patch+json ContentType.
type PatchBridgeWorkerApplicationMergePatchPlusJSONRequestBody PatchBridgeWorkerApplicationMergePatchPlusJSONBody

// UpdateBridgeWorkerJSONRequestBody defines body for UpdateBridgeWorker for application/json ContentType.
type UpdateBridgeWorkerJSONRequestBody = BridgeWorker

// CreateChangeSetJSONRequestBody defines body for CreateChangeSet for application/json ContentType.
type CreateChangeSetJSONRequestBody = ChangeSet

// PatchChangeSetApplicationMergePatchPlusJSONRequestBody defines body for PatchChangeSet for application/merge-patch+json ContentType.
type PatchChangeSetApplicationMergePatchPlusJSONRequestBody PatchChangeSetApplicationMergePatchPlusJSONBody

// UpdateChangeSetJSONRequestBody defines body for UpdateChangeSet for application/json ContentType.
type UpdateChangeSetJSONRequestBody = ChangeSet

// CreateFilterJSONRequestBody defines body for CreateFilter for application/json ContentType.
type CreateFilterJSONRequestBody = Filter

// PatchFilterApplicationMergePatchPlusJSONRequestBody defines body for PatchFilter for application/merge-patch+json ContentType.
type PatchFilterApplicationMergePatchPlusJSONRequestBody PatchFilterApplicationMergePatchPlusJSONBody

// UpdateFilterJSONRequestBody defines body for UpdateFilter for application/json ContentType.
type UpdateFilterJSONRequestBody = Filter

// InvokeFunctionsJSONRequestBody defines body for InvokeFunctions for application/json ContentType.
type InvokeFunctionsJSONRequestBody = FunctionInvocationsRequest

// CreateInvocationJSONRequestBody defines body for CreateInvocation for application/json ContentType.
type CreateInvocationJSONRequestBody = Invocation

// PatchInvocationApplicationMergePatchPlusJSONRequestBody defines body for PatchInvocation for application/merge-patch+json ContentType.
type PatchInvocationApplicationMergePatchPlusJSONRequestBody PatchInvocationApplicationMergePatchPlusJSONBody

// UpdateInvocationJSONRequestBody defines body for UpdateInvocation for application/json ContentType.
type UpdateInvocationJSONRequestBody = Invocation

// CreateLinkJSONRequestBody defines body for CreateLink for application/json ContentType.
type CreateLinkJSONRequestBody = Link

// PatchLinkApplicationMergePatchPlusJSONRequestBody defines body for PatchLink for application/merge-patch+json ContentType.
type PatchLinkApplicationMergePatchPlusJSONRequestBody PatchLinkApplicationMergePatchPlusJSONBody

// UpdateLinkJSONRequestBody defines body for UpdateLink for application/json ContentType.
type UpdateLinkJSONRequestBody = Link

// CreateSetJSONRequestBody defines body for CreateSet for application/json ContentType.
type CreateSetJSONRequestBody = Set

// UpdateSetJSONRequestBody defines body for UpdateSet for application/json ContentType.
type UpdateSetJSONRequestBody = Set

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = Tag

// PatchTagApplicationMergePatchPlusJSONRequestBody defines body for PatchTag for application/merge-patch+json ContentType.
type PatchTagApplicationMergePatchPlusJSONRequestBody PatchTagApplicationMergePatchPlusJSONBody

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = Tag

// CreateTargetJSONRequestBody defines body for CreateTarget for application/json ContentType.
type CreateTargetJSONRequestBody = Target

// PatchTargetApplicationMergePatchPlusJSONRequestBody defines body for PatchTarget for application/merge-patch+json ContentType.
type PatchTargetApplicationMergePatchPlusJSONRequestBody PatchTargetApplicationMergePatchPlusJSONBody

// UpdateTargetJSONRequestBody defines body for UpdateTarget for application/json ContentType.
type UpdateTargetJSONRequestBody = Target

// CreateTriggerJSONRequestBody defines body for CreateTrigger for application/json ContentType.
type CreateTriggerJSONRequestBody = Trigger

// PatchTriggerApplicationMergePatchPlusJSONRequestBody defines body for PatchTrigger for application/merge-patch+json ContentType.
type PatchTriggerApplicationMergePatchPlusJSONRequestBody PatchTriggerApplicationMergePatchPlusJSONBody

// UpdateTriggerJSONRequestBody defines body for UpdateTrigger for application/json ContentType.
type UpdateTriggerJSONRequestBody = Trigger

// CreateUnitJSONRequestBody defines body for CreateUnit for application/json ContentType.
type CreateUnitJSONRequestBody = Unit

// PatchUnitApplicationMergePatchPlusJSONRequestBody defines body for PatchUnit for application/merge-patch+json ContentType.
type PatchUnitApplicationMergePatchPlusJSONRequestBody PatchUnitApplicationMergePatchPlusJSONBody

// UpdateUnitJSONRequestBody defines body for UpdateUnit for application/json ContentType.
type UpdateUnitJSONRequestBody = Unit

// ImportUnitJSONRequestBody defines body for ImportUnit for application/json ContentType.
type ImportUnitJSONRequestBody = ImportRequest

// CreateViewJSONRequestBody defines body for CreateView for application/json ContentType.
type CreateViewJSONRequestBody = View

// PatchViewApplicationMergePatchPlusJSONRequestBody defines body for PatchView for application/merge-patch+json ContentType.
type PatchViewApplicationMergePatchPlusJSONRequestBody PatchViewApplicationMergePatchPlusJSONBody

// UpdateViewJSONRequestBody defines body for UpdateView for application/json ContentType.
type UpdateViewJSONRequestBody = View

// BulkPatchTagsApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchTags for application/merge-patch+json ContentType.
type BulkPatchTagsApplicationMergePatchPlusJSONRequestBody BulkPatchTagsApplicationMergePatchPlusJSONBody

// BulkCreateTagsApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateTags for application/merge-patch+json ContentType.
type BulkCreateTagsApplicationMergePatchPlusJSONRequestBody BulkCreateTagsApplicationMergePatchPlusJSONBody

// BulkPatchTargetsApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchTargets for application/merge-patch+json ContentType.
type BulkPatchTargetsApplicationMergePatchPlusJSONRequestBody BulkPatchTargetsApplicationMergePatchPlusJSONBody

// BulkPatchTriggersApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchTriggers for application/merge-patch+json ContentType.
type BulkPatchTriggersApplicationMergePatchPlusJSONRequestBody BulkPatchTriggersApplicationMergePatchPlusJSONBody

// BulkCreateTriggersApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateTriggers for application/merge-patch+json ContentType.
type BulkCreateTriggersApplicationMergePatchPlusJSONRequestBody BulkCreateTriggersApplicationMergePatchPlusJSONBody

// BulkPatchUnitsApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchUnits for application/merge-patch+json ContentType.
type BulkPatchUnitsApplicationMergePatchPlusJSONRequestBody BulkPatchUnitsApplicationMergePatchPlusJSONBody

// BulkCreateUnitsApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateUnits for application/merge-patch+json ContentType.
type BulkCreateUnitsApplicationMergePatchPlusJSONRequestBody BulkCreateUnitsApplicationMergePatchPlusJSONBody

// BulkTagUnitsJSONRequestBody defines body for BulkTagUnits for application/json ContentType.
type BulkTagUnitsJSONRequestBody = UnitTagRequest

// BulkPatchViewsApplicationMergePatchPlusJSONRequestBody defines body for BulkPatchViews for application/merge-patch+json ContentType.
type BulkPatchViewsApplicationMergePatchPlusJSONRequestBody BulkPatchViewsApplicationMergePatchPlusJSONBody

// BulkCreateViewsApplicationMergePatchPlusJSONRequestBody defines body for BulkCreateViews for application/merge-patch+json ContentType.
type BulkCreateViewsApplicationMergePatchPlusJSONRequestBody BulkCreateViewsApplicationMergePatchPlusJSONBody

// AsFunctionArgumentValue0 returns the union data inside the FunctionArgument_Value as a FunctionArgumentValue0
func (t FunctionArgument_Value) AsFunctionArgumentValue0() (FunctionArgumentValue0, error) {
	var body FunctionArgumentValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionArgumentValue0 overwrites any union data inside the FunctionArgument_Value as the provided FunctionArgumentValue0
func (t *FunctionArgument_Value) FromFunctionArgumentValue0(v FunctionArgumentValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionArgumentValue0 performs a merge with any union data inside the FunctionArgument_Value, using the provided FunctionArgumentValue0
func (t *FunctionArgument_Value) MergeFunctionArgumentValue0(v FunctionArgumentValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionArgumentValue1 returns the union data inside the FunctionArgument_Value as a FunctionArgumentValue1
func (t FunctionArgument_Value) AsFunctionArgumentValue1() (FunctionArgumentValue1, error) {
	var body FunctionArgumentValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionArgumentValue1 overwrites any union data inside the FunctionArgument_Value as the provided FunctionArgumentValue1
func (t *FunctionArgument_Value) FromFunctionArgumentValue1(v FunctionArgumentValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionArgumentValue1 performs a merge with any union data inside the FunctionArgument_Value, using the provided FunctionArgumentValue1
func (t *FunctionArgument_Value) MergeFunctionArgumentValue1(v FunctionArgumentValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionArgumentValue2 returns the union data inside the FunctionArgument_Value as a FunctionArgumentValue2
func (t FunctionArgument_Value) AsFunctionArgumentValue2() (FunctionArgumentValue2, error) {
	var body FunctionArgumentValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionArgumentValue2 overwrites any union data inside the FunctionArgument_Value as the provided FunctionArgumentValue2
func (t *FunctionArgument_Value) FromFunctionArgumentValue2(v FunctionArgumentValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionArgumentValue2 performs a merge with any union data inside the FunctionArgument_Value, using the provided FunctionArgumentValue2
func (t *FunctionArgument_Value) MergeFunctionArgumentValue2(v FunctionArgumentValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FunctionArgument_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FunctionArgument_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
