// Copyright (C) ConfigHub, Inc.
// SPDX-License-Identifier: MIT

// This file is auto-generated by @hey-api/openapi-ts

export type ActionResult = {
    Action?: ActionType;
    /**
     * Configuration data of the Unit
     */
    Data?: string;
    /**
     * Live state corresponding to the Unit
     */
    LiveState?: string;
    Message?: string;
    /**
     * Outputs resulting from applying the configuration data of the Unit
     */
    Outputs?: string;
    /**
     * UUID of the operation corresponding to the action request
     */
    QueuedOperationID?: string;
    Result?: ActionResultType;
    RevisionNum?: number;
    /**
     * UUID of the Space of the Unit on which the action is performed
     */
    SpaceID?: string;
    StartedAt?: string;
    Status?: ActionStatusType;
    TerminatedAt?: string | null;
    /**
     * UUID of the Unit on which the action is performed
     */
    UnitID?: string;
};

export type ActionResultType = 'ApplyFailed' | 'ApplyWaitFailed' | 'ApplyCompleted' | 'DestroyCompleted' | 'DestroyWaitFailed' | 'DestroyFailed' | 'ImportCompleted' | 'ImportFailed' | 'RefreshAndDrifted' | 'RefreshAndNoDrift' | 'RefreshFailed' | 'None';

export const ActionResultType = {
    APPLY_FAILED: 'ApplyFailed',
    APPLY_WAIT_FAILED: 'ApplyWaitFailed',
    APPLY_COMPLETED: 'ApplyCompleted',
    DESTROY_COMPLETED: 'DestroyCompleted',
    DESTROY_WAIT_FAILED: 'DestroyWaitFailed',
    DESTROY_FAILED: 'DestroyFailed',
    IMPORT_COMPLETED: 'ImportCompleted',
    IMPORT_FAILED: 'ImportFailed',
    REFRESH_AND_DRIFTED: 'RefreshAndDrifted',
    REFRESH_AND_NO_DRIFT: 'RefreshAndNoDrift',
    REFRESH_FAILED: 'RefreshFailed',
    NONE: 'None'
} as const;

export type ActionStatusType = 'None' | 'Pending' | 'Submitted' | 'Progressing' | 'Completed' | 'Failed' | 'Canceled';

export const ActionStatusType = {
    NONE: 'None',
    PENDING: 'Pending',
    SUBMITTED: 'Submitted',
    PROGRESSING: 'Progressing',
    COMPLETED: 'Completed',
    FAILED: 'Failed',
    CANCELED: 'Canceled'
} as const;

export type ActionType = 'Apply' | 'Destroy' | 'Finalize' | 'Heartbeat' | 'Import' | 'N/A' | 'Refresh';

export const ActionType = {
    APPLY: 'Apply',
    DESTROY: 'Destroy',
    FINALIZE: 'Finalize',
    HEARTBEAT: 'Heartbeat',
    IMPORT: 'Import',
    N_A: 'N/A',
    REFRESH: 'Refresh'
} as const;

/**
 * Information provided to clients by the server.
 */
export type ApiInfo = {
    /**
     * Build identifier for support cases.
     */
    readonly Build?: string;
    /**
     * The timestamp when ConfigHub was built in "2023-01-01T12:00:00Z" format for support cases.
     */
    readonly BuiltAt?: string;
    /**
     * ClientID for identity provider service.
     */
    readonly ClientID?: string;
    /**
     * Service revision identifier for support cases.
     */
    readonly Revision?: string;
    /**
     * Port number for the worker to connect to the server.
     */
    readonly WorkerPort?: string;
};

/**
 * BridgeWorker represents a bridge worker in ConfigHub.
 * A bridge worker is a worker program that connects ConfigHub to external systems and targets.
 * It acts as a bridge between ConfigHub and the infrastructure where configurations need
 * to be applied. Bridge workers are responsible for executing configuration changes on
 * remote targets and reporting status back to ConfigHub.
 * When starting a bridge worker program, both the BridgeWorkerID and Secret are
 * required for authentication with the ConfigHub server. These credentials allow the
 * bridge worker to establish a secure connection and receive configuration actions.
 */
export type BridgeWorker = {
    /**
     * An optional map of Annotation key/value pairs for tools to attach information to entities.
     */
    Annotations?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for a Bridge Worker.
     */
    BridgeWorkerID?: string;
    /**
     * Condition represents the worker's readiness state (Ready, NotReady, Unknown).
     */
    Condition?: string;
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
     */
    Labels?: {
        [key: string]: string;
    };
    /**
     * LastHeartbeatMessage contains the message from the last heartbeat.
     */
    LastHeartbeatMessage?: string;
    /**
     * LastHeartbeatReceivedAt is the time the last heartbeat was received.
     */
    LastHeartbeatReceivedAt?: string;
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    ProvidedInfo?: WorkerInfo;
    /**
     * Secret is a unique secret token for the bridge worker.
     * It's auto-generated when the BridgeWorker entity is created and cannot be modified.
     * This field is output-only and used for authentication.
     * This secret is required when starting the bridge worker program.
     */
    Secret?: string;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type BridgeWorkerExtended = {
    BridgeWorker?: BridgeWorker;
};

export type BridgeWorkerInfo = {
    /**
     * Configuration types supported by the BridgeWorker
     */
    SupportedConfigTypes?: Array<ConfigType>;
};

/**
 * BridgeWorkerStatus represents the status information of a bridge worker within the system.
 */
export type BridgeWorkerStatus = {
    /**
     * Unique identifier for the Bridge Worker.
     */
    BridgeWorkerID?: string;
    /**
     * Slug for the Bridge Worker.
     */
    BridgeWorkerSlug?: string;
    /**
     * BridgeWorkerStatusID is the unique identifier for the bridge worker status entry.
     */
    BridgeWorkerStatusID?: string;
    /**
     * IPAddress is the IP address from which the bridge worker is connecting.
     */
    IPAddress?: string;
    /**
     * OrganizationID is the unique identifier of the organization the bridge worker belongs to.
     */
    OrganizationID?: string;
    /**
     * The timestamp when the bridge worker last responded in "2023-01-01T12:00:00Z" format.
     */
    SeenAt?: string;
    /**
     * SpaceID is the unique identifier of the space the bridge worker belongs to.
     */
    SpaceID?: string;
    /**
     * Status indicates the current status of the bridge worker. Possible values include Connected, Disconnected, ActionSent, ActionResultReceived.
     */
    Status?: string;
};

export type ConfigType = {
    /**
     * Targets known by the BridgeWorker
     */
    AvailableTargets?: Array<TargetType2>;
    /**
     * Provider subtype of the configuration toolchain supported by the BridgegWorker
     */
    ProviderType?: string;
    /**
     * Configuration toolchain and format supported by the BridgeWorker
     */
    ToolchainType?: string;
};

/**
 * Response for successful delete operation
 */
export type DeleteResponse = {
    /**
     * Response message.
     */
    Message?: string;
};

export type EventMessage = {
    Data?: string;
    Event?: string;
};

export type ExtendedBridgeWorker = {
    BridgeWorker?: BridgeWorker;
    Organization?: Organization;
    Space?: Space;
};

export type ExtendedLink = {
    FromUnit?: Unit;
    Link?: Link;
    Organization?: Organization;
    Space?: Space;
    ToSpace?: Space;
    ToUnit?: Unit;
};

export type ExtendedMutation = {
    Link?: Link;
    Mutation?: Mutation;
    Organization?: Organization;
    Revision?: Revision;
    Space?: Space;
    Trigger?: Trigger;
    Unit?: Unit;
};

export type ExtendedRevision = {
    Organization?: Organization;
    Revision?: Revision;
    Space?: Space;
    Unit?: Unit;
    User?: User;
};

export type ExtendedSet = {
    Organization?: Organization;
    Set?: _Set;
    Space?: Space;
};

export type ExtendedSpace = {
    GatedUnitCount?: number;
    IncompleteApplyUnitCount?: number;
    Organization?: Organization;
    RecentChangeUnitCount?: number;
    Space?: Space;
    TargetCountByToolchainType?: {
        [key: string]: number;
    } | null;
    TotalBridgeWorkerCount?: number;
    TotalUnitCount?: number;
    TriggerCountByEventType?: {
        [key: string]: number;
    } | null;
    UnappliedUnitCount?: number;
    UnapprovedUnitCount?: number;
    UnlinkedUnitCount?: number;
    UpgradableUnitCount?: number;
};

export type ExtendedTarget = {
    BridgeWorker?: BridgeWorker;
    Organization?: Organization;
    Space?: Space;
    Target?: Target;
};

export type ExtendedTrigger = {
    BridgeWorker?: BridgeWorker;
    Organization?: Organization;
    Space?: Space;
    Trigger?: Trigger;
};

/**
 * Unit with capability to extend additional related entities.
 */
export type ExtendedUnit = {
    /**
     * the users that have approved the latest revision of the config data.
     */
    ApprovedBy?: Array<User>;
    HeadMutation?: Mutation;
    HeadRevision?: Revision;
    LastAppliedRevision?: Revision;
    LatestUnitEvent?: UnitEvent;
    LiveRevision?: Revision;
    Organization?: Organization;
    Set?: _Set;
    Space?: Space;
    Target?: Target;
    Unit?: Unit;
    UnitStatus?: UnitStatus;
    UpstreamSpace?: Space;
    UpstreamUnit?: Unit;
};

export type FunctionArgument = {
    ParameterName?: string;
    Value?: string | number | boolean;
};

export type FunctionInvocation = {
    /**
     * Function arguments
     */
    Arguments?: Array<FunctionArgument> | null;
    /**
     * Function name
     */
    FunctionName?: string;
};

export type FunctionInvocationList = Array<FunctionInvocation> | null;

export type FunctionInvocationResponse = {
    /**
     * The resulting configuration data, potentially mutated
     */
    ConfigData?: string;
    /**
     * Error messages from function execution; will be empty if Success is true
     */
    ErrorMessages?: Array<string> | null;
    Mutations?: ResourceMutationList;
    /**
     * List of function invocation indices that resulted in mutations
     */
    Mutators?: Array<number> | null;
    /**
     * ID of the Unit's Organization
     */
    OrganizationID?: string;
    /**
     * Output other than config data, as embedded JSON
     */
    Output?: string;
    /**
     * Type of structured function output, if any
     */
    OutputType?: string;
    /**
     * ID of the Revision the configuration data is associated with
     */
    RevisionID?: string;
    /**
     * ID of the Unit's Space
     */
    SpaceID?: string;
    /**
     * True if all functions executed successfully
     */
    Success?: boolean;
    /**
     * ID of the Unit the configuration data is associated with
     */
    UnitID?: string;
};

/**
 * FunctionInvocationsRequest represents a request to invoke a list of functions on the configuration data of the matching Units or Revision.
 */
export type FunctionInvocationsRequest = {
    /**
     * CastStringArgsToScalars indicates whether to expect string arguments and cast them to int and bool types as necessary.
     */
    CastStringArgsToScalars?: boolean;
    /**
     * ChangeDescription is a description of the change being made, if any.
     */
    ChangeDescription?: string;
    /**
     * CombineResults indicates whether to combine the Outputs of all functions in the FunctionInvocations list. In the case of ValidationResult, the Passed results are ANDed together and a single ValidationResult is returned instead of a ValidationResultList. In the case of AttributeValueList and ResourceInfoList, the lists are concatenated. All output-generating functions must return the same OutputType, or only the first OutputType will be returned.
     */
    CombineResults?: boolean;
    FunctionInvocations?: FunctionInvocationList;
    /**
     * NumFilters is the number of validating functions from the FunctionInvocations to treat as filters for the remaining functions in the list. In the case that the validation function does not pass, stop and don't execute the remaining functions, but don't report an error.
     */
    NumFilters?: number;
    /**
     * StopOnError indicates whether to stop executing functions from the FunctionInvocations list on the first error, or to execute all of the functions and return all of the errors.
     */
    StopOnError?: boolean;
    /**
     * UseFunctionWorker indicates whether to use the function worker or the builtin function executor, which is the default. The FunctionInvocations are forwarded to the executor/worker, so all must be executable by the same executor/worker currently.
     */
    UseFunctionWorker?: boolean;
};

export type FunctionOutput = {
    /**
     * Description of the result
     */
    Description?: string;
    /**
     * Data type of the JSON embedded in the output
     */
    OutputType?: string;
    /**
     * Name of the result in kabob-case
     */
    ResultName?: string;
};

export type FunctionParameter = {
    /**
     * Data type of the parameter
     */
    DataType?: string;
    /**
     * Description of the parameter
     */
    Description?: string;
    /**
     * List of valid enum values; applies to enum parameters
     */
    EnumValues?: Array<string>;
    /**
     * Example value
     */
    Example?: string;
    /**
     * Maximum allowed value; applies to int parameters
     */
    Max?: number | null;
    /**
     * Minimum allowed value; applies to int parameters
     */
    Min?: number | null;
    /**
     * Name of the parameter in kabob-case
     */
    ParameterName?: string;
    /**
     * Regular expression matching valid values; applies to string parameters
     */
    Regexp?: string;
    /**
     * Whether the parameter is required
     */
    Required?: boolean;
};

export type FunctionSignature = {
    /**
     * Resource types the function applies to; * if all
     */
    AffectedResourceTypes?: Array<string>;
    /**
     * Attribute corresponding to registered paths, if a path visitor; optional
     */
    AttributeName?: string;
    /**
     * Description of the function
     */
    Description?: string;
    /**
     * Name of the function in kabob-case
     */
    FunctionName?: string;
    /**
     * Implementation pattern of the function: PathVisitor or Custom
     */
    FunctionType?: string;
    /**
     * Does not call other systems
     */
    Hermetic?: boolean;
    /**
     * Will return the same result if invoked again
     */
    Idempotent?: boolean;
    /**
     * May change the configuration data
     */
    Mutating?: boolean;
    OutputInfo?: FunctionOutput;
    /**
     * Function parameters, in order
     */
    Parameters?: Array<FunctionParameter> | null;
    /**
     * Number of required parameters
     */
    RequiredParameters?: number;
    /**
     * Returns ValidationResult
     */
    Validating?: boolean;
    /**
     * Last parameter may be repeated
     */
    VarArgs?: boolean;
};

export type FunctionWorkerInfo = {
    SupportedFunctions?: {
        [key: string]: {
            [key: string]: FunctionSignature;
        };
    } | null;
};

export type ImportRequest = {
    ResourceInfoList?: ResourceInfoList;
};

/**
 * Link connects two config Units in a dependency / producer-consumer relationship.
 * A Link indicates that config values Provided by the To Unit (the producer) may
 * satisfy config values Needed by the From Unit (the consumer), and should be attempted
 * to be matched before values Provided by other Units in the Space (if within the same
 * Space). Links must be created in the same Space as the From Unit.
 * They also imply an ordering when Applied or Destroyed as a Set.
 */
export type Link = {
    /**
     * An optional map of Annotation key/value pairs for tools to attach information to entities.
     */
    Annotations?: {
        [key: string]: string;
    };
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * Unique identifier the Unit the Link initiates from. Links must be in the same space as the source unit.
     */
    FromUnitID?: string;
    /**
     * An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
     */
    Labels?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for a Link.
     */
    LinkID?: string;
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    /**
     * Unique identifier the Space of the Unit the Link targets.
     */
    ToSpaceID?: string;
    /**
     * Unique identifier the Unit the Link targets.
     */
    ToUnitID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type LinkExtended = {
    FromSpaceSlug?: string;
    FromUnitSlug?: string;
    Link?: Link;
    ToSpaceSlug?: string;
    ToUnitSlug?: string;
};

/**
 * Mutation is a single source of mutation for a Revision.
 */
export type Mutation = {
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * The type of entity.
     */
    EntityType?: string;
    FunctionInvocation?: FunctionInvocation;
    LinkID?: Uuid;
    /**
     * Unique identifier for a Mutation.
     */
    MutationID?: string;
    /**
     * Sequence number for the Mutation.
     */
    MutationNum?: number;
    /**
     * Unique identifier for an Organization.
     */
    OrganizationID?: string;
    /**
     * ProvidedPath is the path of the provided value used to satisfy a needed value if the change was made due to resolving a link.
     */
    ProvidedPath?: string;
    ProvidedResource?: ResourceInfo;
    /**
     * Unique identifier of the corresponding Revision.
     */
    RevisionID?: string;
    /**
     * Sequence number of the corresponding Revision.
     */
    RevisionNum?: number;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    TriggerID?: Uuid;
    /**
     * Unique identifier for a Unit.
     */
    UnitID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type MutationExtended = {
    Mutation?: Mutation;
};

export type MutationInfo = {
    /**
     * Function index or sequence number corresponding to the change
     */
    Index?: number;
    MutationType?: MutationType;
    /**
     * Used to decide how to use the mututation
     */
    Predicate?: boolean;
    /**
     * Removed configuration data if MutationType is Delete and otherwise the new data
     */
    Value?: string;
};

export type MutationMap = {
    [key: string]: MutationInfo;
};

export type MutationType = 'Add' | 'Delete' | 'Update' | 'Replace' | 'None';

export const MutationType = {
    ADD: 'Add',
    DELETE: 'Delete',
    UPDATE: 'Update',
    REPLACE: 'Replace',
    NONE: 'None'
} as const;

/**
 * The top-level container for an organization using ConfigHub.
 */
export type Organization = {
    /**
     * An optional map of Annotation key/value pairs for tools to attach information to entities.
     */
    Annotations?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for a billing account for the organization.
     */
    BillingAccountID?: string;
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * Unique identifier for the External Identity Provider record matching this organization.
     */
    ExternalID?: string;
    /**
     * An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
     */
    Labels?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type OrganizationExtended = {
    Organization?: Organization;
};

/**
 * a User given membership on the Organization
 */
export type OrganizationMember = {
    /**
     * Friendly name for the organization member User.
     */
    DisplayName?: string;
    /**
     * Unique identifier for the External Identity Provider record matching this User.
     */
    ExternalID?: string;
    /**
     * Unique identifier for the External Identity Provider record matching this organization.
     */
    ExternalOrganizationID?: string;
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    /**
     * The URL to get the profile avatar picture of the User.
     */
    ProfilePictureURL?: string;
    /**
     * Unique URL-safe identifier for the organization member User.
     */
    Slug?: string;
    /**
     * Unique identifier for the organization member User.
     */
    UserID?: string;
    /**
     * Unique username for a User. Must be unique for all of ConfigHub.
     */
    Username?: string;
};

/**
 * QueuedOperation is a record of an operation to be done by a bridge worker.
 */
export type QueuedOperation = {
    Action?: ActionType;
    /**
     * BridgeWorkerID is the unique identifier of the bridge worker that will process this operation.
     */
    BridgeWorkerID?: string;
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    CreatedAt?: string;
    /**
     * ExtraParams contains additional parameters for the operation in string format.
     */
    ExtraParams?: string;
    /**
     * OrganizationID is the unique identifier of the organization this operation belongs to.
     */
    OrganizationID?: string;
    /**
     * QueuedOperationID is the unique identifier for the queued operation.
     */
    QueuedOperationID?: string;
    /**
     * RevisionNum is the revision number this operation was performed on.
     */
    RevisionNum?: number;
    /**
     * SpaceID is the unique identifier of the space of the unit this operation is performed on.
     */
    SpaceID?: string;
    /**
     * Status indicates the current status of the queued operation.
     */
    Status?: string;
    /**
     * TargetID is the unique identifier of the target this operation is directed to.
     */
    TargetID?: string;
    /**
     * UnitID is the unique identifier of the unit this operation is performed on.
     */
    UnitID?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    Version?: number;
};

export type ResourceInfo = {
    /**
     * Category of configuration element represented in the configuration data; Kubernetes and OpenTofu resources are of category Resource, and application configuration files are of category AppConfig
     */
    ResourceCategory?: string;
    /**
     * Name of a resource in the system under management represented in the configuration data; Kubernetes resources are represented in the form <metadata.namespace>/<metadata.name>; not all ToolchainTypes necessarily use '/' as a separator between any scope(s) and name or other client-chosen ID
     */
    ResourceName?: string;
    /**
     * Name of a resource in the system under management represented in the configuration data, without any uniquifying scope, such as Namespace, Project, Account, Region, etc.; Kubernetes resources are represented in the form <metadata.name>
     */
    ResourceNameWithoutScope?: string;
    /**
     * Type of a resource in the system under management represented in the configuration data; Kubernetes resources are represented in the form <apiVersion>/<kind> (aka group-version-kind)
     */
    ResourceType?: string;
};

export type ResourceInfoList = Array<ResourceInfo>;

export type ResourceMutation = {
    /**
     * Names (with scopes, if any) used in current and prior revisions of this resource
     */
    Aliases?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    /**
     * Names without scopes used in current and prior revisions of this resource
     */
    AliasesWithoutScopes?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    PathMutationMap?: MutationMap;
    Resource?: ResourceInfo;
    ResourceMutationInfo?: MutationInfo;
};

export type ResourceMutationList = Array<ResourceMutation> | null;

/**
 * Revision is a historial view of a Config Unit.
 */
export type Revision = {
    /**
     * A map of "<trigger slug>/<function name>" to true of Triggers invoking validating functions that did not pass on the configuration data at this Revision.
     */
    ApplyGates?: {
        [key: string]: boolean;
    };
    /**
     * the users that have approved the latest version of the config data for the Unit.
     */
    ApprovedBy?: Array<Uuid> | null;
    /**
     * The CRC32 hash of this revision's data.
     */
    ContentHash?: number;
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * The full configuration data for this unit at this revision.
     */
    Data?: string;
    /**
     * User description of the change. It is copied from the LastChangeDescription field of the Unit at the time the change was made that created the Revision.
     */
    Description?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * Time at which the revision was applied, if it was applied. If not applied, the value is "0001-01-01T00:00:00Z".
     */
    LiveAt?: string;
    MutationSources?: ResourceMutationList;
    /**
     * Unique identifier for an Organization.
     */
    OrganizationID?: string;
    /**
     * Unique identifier for a Revision.
     */
    RevisionID?: string;
    /**
     * Sequence number for a Revision.
     */
    RevisionNum?: number;
    /**
     * ConfigHub operation that created this revision.
     */
    Source?: string;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    /**
     * Unique identifier for a Unit.
     */
    UnitID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * User-Agent string if created by an API call. Optional.
     */
    UserAgent?: string;
    /**
     * UserID if change was made by a user. Automated changes, such as by triggers and resolve, are currently made with the UserID "00000000-0000-0000-0000-000000000000".
     */
    UserID?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type RevisionExtended = {
    ApprovedByUsers?: Array<string> | null;
    Revision?: Revision;
    Username?: string;
};

/**
 * A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
 */
export type _Set = {
    /**
     * An optional map of Annotation key/value pairs for tools to attach information to entities.
     */
    Annotations?: {
        [key: string]: string;
    };
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
     */
    Labels?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    /**
     * Unique identifier for a Set.
     */
    SetID?: string;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type SetExtended = {
    Set?: _Set;
};

/**
 * The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
 */
export type Space = {
    /**
     * An optional map of Annotation key/value pairs for tools to attach information to entities.
     */
    Annotations?: {
        [key: string]: string;
    };
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
     */
    Labels?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type SpaceExtended = {
    Space?: Space;
};

/**
 * Error response details.
 */
export type StandardErrorResponse = {
    /**
     * HTTP status code of the response.
     */
    Code?: string;
    /**
     * Message returned with the response.
     */
    Message?: string;
};

/**
 * Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
 */
export type Target = {
    /**
     * An optional map of Annotation key/value pairs for tools to attach information to entities.
     */
    Annotations?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for a Bridge Worker associated with the Target.
     */
    BridgeWorkerID?: string;
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
     */
    Labels?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    /**
     * Parameters contains toolchain-type and/or provider-type-specific parameters in JSON format.
     *
     * For ProviderType: Kubernetes (ToolchainType: Kubernetes/YAML)
     * The Parameters object may contain the following fields:
     * - "KubeContext" (string): The name of the Kubernetes context (from "~/.kube/config") to use. (Not typically needed if running in-cluster).
     * - "KubeNamespace" (string, optional): The target Kubernetes namespace for applying or managing resources.
     * - "WaitTimeout" (string): A duration string (e.g., "5m", "2m30s") specifying how long to wait for resources to reach a ready state. Defaults to "2m0s".
     *
     * For ProviderType: FluxOCIWriter (ToolchainType: Kubernetes/YAML)
     * The Parameters object may contain the following fields:
     * - "Repository" (string, required): The base OCI repository URL (e.g., "oci://ghcr.io/my-org"). The 'UnitSlug' (a system-provided identifier for the configuration unit) will be appended to this URL to form the full image path (e.g., "oci://ghcr.io/my-org/<UnitSlug>").
     * - "Tag" (string, optional): Explicit OCI tag for the image. Confighub will automatically set the tag on each push using the Unit's current RevisionNum being applied. This will have 'rev' prefixed to the number, like 'rev42'. When Tag is populated, it can be used to explicitly set a value that you want Confighub to publish to the OCI in addition to the default RevisionNum tag. For example 'latest' or 'trunk'.
     * - "Provider" (string, optional): Specifies the authentication provider for the OCI registry. Defaults to "None".
     * Possible values:
     * - "None": Uses local Docker configuration (e.g., from '~/.docker/config.json') or the system's credential keychain.
     * - "Generic": Uses generic OCI provider authentication.
     * - "AWS": Uses AWS ECR authentication.
     * - "Azure": Uses Azure CR authentication.
     * - "GCP": Uses Google CR/Artifact Registry authentication.
     * - "AllowDeletion" (string, optional): A boolean string ("true" or "false") indicating if the worker is allowed to delete images from the repository. Defaults to "false".
     * - "KubernetesSecretName" (string, optional): The name of a Kubernetes Secret containing Docker credentials. The secret should typically have a '.dockerconfigjson' key, or 'username' and 'password' keys.
     * - "KubernetesSecretNamespace" (string, optional): The Kubernetes namespace where the "KubernetesSecretName" is located. If not specified, the secret is assumed to be in the same namespace as the ConfigHub worker.
     *
     */
    Parameters?: string;
    /**
     * ProviderType specifies the cloud or infrastructure provider for this target, such as "Kubernetes" or "AWS".
     */
    ProviderType?: string;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    /**
     * Unique identifier for a Target.
     */
    TargetID?: string;
    /**
     * ToolchainType specifies the type of toolchain supported by this Target. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
     */
    ToolchainType?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type TargetExtended = {
    Target?: Target;
};

export type TargetType2 = {
    /**
     * Used to set the Slug and DisplayName of the Target created in ConfigHub
     */
    Name?: string;
    /**
     * Used to set the Parameters of the Target created in ConfigHub
     */
    Params?: {};
};

/**
 * Defines an automated function invocation that executes in response to specific
 * Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
 * automated transformations, or other custom logic that should run when configuration
 * changes occur. Each Trigger is associated with a specific Space and can be configured
 * to execute on events.
 *
 * Triggers can be either validating (checking configuration validity without modifying it)
 * or mutating (making changes to the configuration). They can also be enforced (cannot be
 * overridden) or disabled.
 */
export type Trigger = {
    /**
     * An optional map of Annotation key/value pairs for tools to attach information to entities.
     */
    Annotations?: {
        [key: string]: string;
    };
    /**
     * Function arguments
     */
    Arguments?: Array<FunctionArgument> | null;
    BridgeWorkerID?: Uuid;
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * Disabled indicates whether this trigger is currently disabled.
     * When disabled, the trigger will not be executed even when matching events occur.
     */
    Disabled?: boolean;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * Enforced indicates whether this trigger cannot be overridden.
     * Enforced triggers implement mandatory policies that cannot be bypassed.
     */
    Enforced?: boolean;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * Event specifies the type of event that will activate this trigger. Valid values are Mutation, PreClone, and PostClone
     */
    Event?: string;
    /**
     * Function name
     */
    FunctionName?: string;
    /**
     * An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
     */
    Labels?: {
        [key: string]: string;
    };
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    /**
     * ToolchainType specifies the type of toolchain this trigger works with.
     * This determines which configuration formats the trigger can process.
     */
    ToolchainType?: string;
    /**
     * TriggerID uniquely identifies a trigger within the system.
     */
    TriggerID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * Validating indicates whether this is a validating function (true) or mutating function (false).
     * Validating functions check configuration validity without modifying it. Mutating functions can make changes to the configuration.
     * This value is returned by ConfigHub based on the corresponding property of the specified function.
     */
    Validating?: boolean;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type TriggerExtended = {
    Trigger?: Trigger;
};

export type Uuid = string;

/**
 * Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
 * of a single supported Toolchain Type (congifuration format). This blob is typically a text document
 * that contains a collection of Kubernetes or infrastructure resources, or an application configuration
 * file. Applying / deploying or destroying the configuration happens as a single "transaction"
 * from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
 * the underlying configuration / deployment tool. The resources must belong to a single
 * infrastructure provider and the actuation mechanism must be able to resolve references and
 * ordering dependencies among the resources within the document. For example, if one resource
 * needs to be fully provisioned to provide input to another resource, then the actuation code is
 * responsible for handling this. Revisions store historical copies of the configuration data.
 * Configuration data can be restored from prior Revisions. Units can also be cloned to create
 * new variants of a configuration.
 */
export type Unit = {
    /**
     * An optional map of Annotation key/value pairs for tools to attach information to entities.
     */
    Annotations?: {
        [key: string]: string;
    };
    /**
     * A map of "<trigger slug>/<function name>" to true of Triggers invoking validating functions that did not pass on the latest configuration data.
     */
    ApplyGates?: {
        [key: string]: boolean;
    };
    /**
     * The users that have approved the latest revision of the config data for the Unit.
     */
    ApprovedBy?: Array<Uuid> | null;
    /**
     * The CRC32 hash of the configuration data.
     */
    ContentHash?: number;
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * The full configuration data for this unit.
     */
    Data?: string;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * Sequence number the head Mutation.
     */
    HeadMutationNum?: number;
    /**
     * Sequence number the head Revision.
     */
    HeadRevisionNum?: number;
    /**
     * An optional map of Label key/value pairs to specify identifying attributes of entities for the purpose of grouping and filtering them.
     */
    Labels?: {
        [key: string]: string;
    };
    /**
     * Sequence number the last Revision applied. 0 if no live revision.
     */
    LastAppliedRevisionNum?: number;
    /**
     * LastChangeDescription is a human-readable description of the last change. This description is copied to the new Revision when the Data is changed.
     */
    LastChangeDescription?: string;
    /**
     * Sequence number the last Revision applied once apply has completed. 0 if no live revision.
     */
    LiveRevisionNum?: number;
    /**
     * The current live state of the Unit as reported by the bridge worker associated with the Target attached to the Unit.
     */
    LiveState?: string;
    MutationSources?: ResourceMutationList;
    /**
     * Unique identifier for an organization.
     */
    OrganizationID?: string;
    /**
     * The outputs of the last successful apply of the Unit.
     */
    Outputs?: string;
    /**
     * Sequence number the previous Revision applied. 0 if no live revision.
     */
    PreviousLiveRevisionNum?: number;
    SetID?: Uuid;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    TargetID?: Uuid;
    /**
     * ToolchainType specifies the type of toolchain for this unit. Possible values include "Kubernetes/YAML", "OpenTofu/HCL", "AppConfig/Properties".
     */
    ToolchainType?: string;
    /**
     * Unique identifier for a Unit.
     */
    UnitID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    UpstreamOrganizationID?: Uuid;
    /**
     * Sequence number for the Revision of the Unit this unit was cloned from, or 0. This is updated to the upstream Unit's head revision number when the Unit is upgraded.
     */
    UpstreamRevisionNum?: number;
    UpstreamSpaceID?: Uuid;
    UpstreamUnitID?: Uuid;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

/**
 * UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks
 * the lifecycle of applying, destroying, or refreshing a Unit's configuration in the target
 * live system. The event captures the current status of the operation, any configuration
 * drift detected, and timing information about when the action started and completed.
 * Actions are atomic from ConfigHub's perspective but may involve multiple steps
 * in the connected Bridge. The status and drift detection help track the health
 * and consistency of the provisioned configuration compared to what is defined in the Unit.
 */
export type UnitEvent = {
    Action?: ActionType;
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * The type of entity.
     */
    EntityType?: string;
    Message?: string;
    /**
     * Unique identifier for an Organization.
     */
    OrganizationID?: string;
    /**
     * QueuedOperationID is the unique identifier for the corresponding queued operation.
     */
    QueuedOperationID?: string;
    Result?: ActionResultType;
    RevisionNum?: number;
    /**
     * Unique identifier for a space.
     */
    SpaceID?: string;
    StartedAt?: string;
    Status?: ActionStatusType;
    TerminatedAt?: string | null;
    UnitEventID?: string;
    /**
     * Unique identifier for a Unit.
     */
    UnitID?: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type UnitExtended = {
    Action?: ActionType;
    ActionResult?: ActionResultType;
    ActionStartedAt?: string | null;
    ActionTerminatedAt?: string | null;
    ApprovedByUsers?: Array<string> | null;
    Drift?: string;
    FromLinks?: Array<Link> | null;
    Status?: string;
    ToLinks?: Array<Link> | null;
    Unit?: Unit;
};

export type UnitStatus = {
    Action?: ActionType;
    ActionResult?: ActionResultType;
    ActionStartedAt?: string | null;
    ActionTerminatedAt?: string | null;
    Drift?: string;
    Status?: string;
};

export type UpgradeUnitResponse = {
    FailedUnits?: {
        [key: string]: string;
    } | null;
    UpgradedUnits?: Array<Unit> | null;
};

/**
 * a User in Confighub.
 */
export type User = {
    /**
     * The timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
     */
    readonly CreatedAt?: string;
    /**
     * An auto-incrementing sequence number used for pagination.
     */
    readonly CursorID?: number;
    /**
     * Friendly name for the entity.
     */
    DisplayName?: string;
    /**
     * The type of entity.
     */
    EntityType?: string;
    /**
     * Unique identifier for the External Identity Provider record matching this User.
     */
    ExternalID?: string;
    /**
     * The URL to get the profile avatar picture of the User.
     */
    ProfilePictureURL?: string;
    /**
     * Unique URL-safe identifier for the entity.
     */
    Slug: string;
    /**
     * The timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
     */
    readonly UpdatedAt?: string;
    /**
     * Unique identifier for a User.
     */
    UserID?: string;
    /**
     * Unique username for a User. Must be unique for all of Confighub.
     */
    Username?: string;
    /**
     * An entity-specific sequence number used for optimistic concurrency control.
     * The value read must be sent in calls to Update.
     */
    readonly Version?: number;
};

export type WorkerInfo = {
    BridgeWorkerInfo?: BridgeWorkerInfo;
    FunctionWorkerInfo?: FunctionWorkerInfo;
};

export type ListAllBridgeWorkersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Include clause for expanding related entities in the response for bridge_worker.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for bridge_worker are OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on bridge_worker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
    };
    url: '/bridge_worker';
};

export type ListAllBridgeWorkersErrors = {
    default: Array<BridgeWorker>;
};

export type ListAllBridgeWorkersError = ListAllBridgeWorkersErrors[keyof ListAllBridgeWorkersErrors];

export type ListAllBridgeWorkersResponses = {
    /**
     * OK
     */
    200: Array<BridgeWorker>;
};

export type ListAllBridgeWorkersResponse = ListAllBridgeWorkersResponses[keyof ListAllBridgeWorkersResponses];

export type CreateActionResultData = {
    body?: ActionResult;
    path: {
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: never;
    url: '/bridge_worker/{bridge_worker_id}/action_result';
};

export type CreateActionResultErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
    default: string;
};

export type CreateActionResultError = CreateActionResultErrors[keyof CreateActionResultErrors];

export type CreateActionResultResponses = {
    /**
     * OK
     */
    200: string;
};

export type CreateActionResultResponse = CreateActionResultResponses[keyof CreateActionResultResponses];

export type GetSelfData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: never;
    url: '/bridge_worker/{bridge_worker_id}/me';
};

export type GetSelfErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
    /**
     * BridgeWorker represents a bridge worker in ConfigHub.
     * A bridge worker is a worker program that connects ConfigHub to external systems and targets.
     * It acts as a bridge between ConfigHub and the infrastructure where configurations need
     * to be applied. Bridge workers are responsible for executing configuration changes on
     * remote targets and reporting status back to ConfigHub.
     * When starting a bridge worker program, both the BridgeWorkerID and Secret are
     * required for authentication with the ConfigHub server. These credentials allow the
     * bridge worker to establish a secure connection and receive configuration actions.
     */
    default: BridgeWorker;
};

export type GetSelfError = GetSelfErrors[keyof GetSelfErrors];

export type GetSelfResponses = {
    /**
     * BridgeWorker represents a bridge worker in ConfigHub.
     * A bridge worker is a worker program that connects ConfigHub to external systems and targets.
     * It acts as a bridge between ConfigHub and the infrastructure where configurations need
     * to be applied. Bridge workers are responsible for executing configuration changes on
     * remote targets and reporting status back to ConfigHub.
     * When starting a bridge worker program, both the BridgeWorkerID and Secret are
     * required for authentication with the ConfigHub server. These credentials allow the
     * bridge worker to establish a secure connection and receive configuration actions.
     */
    200: BridgeWorker;
};

export type GetSelfResponse = GetSelfResponses[keyof GetSelfResponses];

export type StreamBridgeWorkerData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: never;
    url: '/bridge_worker/{bridge_worker_id}/stream';
};

export type StreamBridgeWorkerErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
    default: EventMessage;
};

export type StreamBridgeWorkerError = StreamBridgeWorkerErrors[keyof StreamBridgeWorkerErrors];

export type StreamBridgeWorkerResponses = {
    /**
     * OK
     */
    200: EventMessage;
};

export type StreamBridgeWorkerResponse = StreamBridgeWorkerResponses[keyof StreamBridgeWorkerResponses];

export type ListOrgFunctionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/function';
};

export type ListOrgFunctionsErrors = {
    /**
     * Function request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Function not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Function.
     */
    500: StandardErrorResponse;
    default: {
        [key: string]: {
            [key: string]: FunctionSignature;
        };
    };
};

export type ListOrgFunctionsError = ListOrgFunctionsErrors[keyof ListOrgFunctionsErrors];

export type ListOrgFunctionsResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: {
            [key: string]: FunctionSignature;
        };
    };
};

export type ListOrgFunctionsResponse = ListOrgFunctionsResponses[keyof ListOrgFunctionsResponses];

export type InvokeFunctionsOnOrgData = {
    body?: FunctionInvocationsRequest;
    path?: never;
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
         *
         * Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
    };
    url: '/function/invoke';
};

export type InvokeFunctionsOnOrgErrors = {
    /**
     * Function request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Function not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Function.
     */
    500: StandardErrorResponse;
    default: Array<FunctionInvocationResponse>;
};

export type InvokeFunctionsOnOrgError = InvokeFunctionsOnOrgErrors[keyof InvokeFunctionsOnOrgErrors];

export type InvokeFunctionsOnOrgResponses = {
    /**
     * OK
     */
    200: Array<FunctionInvocationResponse>;
};

export type InvokeFunctionsOnOrgResponse = InvokeFunctionsOnOrgResponses[keyof InvokeFunctionsOnOrgResponses];

export type ApiInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/info';
};

export type ApiInfoErrors = {
    /**
     * Information provided to clients by the server.
     */
    default: ApiInfo;
};

export type ApiInfoError = ApiInfoErrors[keyof ApiInfoErrors];

export type ApiInfoResponses = {
    /**
     * Information provided to clients by the server.
     */
    200: ApiInfo;
};

export type ApiInfoResponse = ApiInfoResponses[keyof ApiInfoResponses];

export type GetMeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/me';
};

export type GetMeErrors = {
    /**
     * UserInfo request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * UserInfo not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing UserInfo.
     */
    500: StandardErrorResponse;
    /**
     * a User given membership on the Organization
     */
    default: OrganizationMember;
};

export type GetMeError = GetMeErrors[keyof GetMeErrors];

export type GetMeResponses = {
    /**
     * a User given membership on the Organization
     */
    200: OrganizationMember;
};

export type GetMeResponse = GetMeResponses[keyof GetMeResponses];

export type ListOrganizationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Organization: BillingAccountID, CreatedAt, DisplayName, ExternalID, Labels, OrganizationID, Slug, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Organization.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Organization are .
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/organization';
};

export type ListOrganizationsErrors = {
    /**
     * Organization request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Organization not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Organization.
     */
    500: StandardErrorResponse;
    default: Array<Organization>;
};

export type ListOrganizationsError = ListOrganizationsErrors[keyof ListOrganizationsErrors];

export type ListOrganizationsResponses = {
    /**
     * OK
     */
    200: Array<Organization>;
};

export type ListOrganizationsResponse = ListOrganizationsResponses[keyof ListOrganizationsResponses];

export type CreateOrganizationData = {
    body?: Organization;
    path?: never;
    query?: never;
    url: '/organization';
};

export type CreateOrganizationErrors = {
    /**
     * Organization request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Organization not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Organization.
     */
    500: StandardErrorResponse;
    /**
     * The top-level container for an organization using ConfigHub.
     */
    default: Organization;
};

export type CreateOrganizationError = CreateOrganizationErrors[keyof CreateOrganizationErrors];

export type CreateOrganizationResponses = {
    /**
     * The top-level container for an organization using ConfigHub.
     */
    200: Organization;
};

export type CreateOrganizationResponse = CreateOrganizationResponses[keyof CreateOrganizationResponses];

export type DeleteOrganizationData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a organization_id
         */
        organization_id: string;
    };
    query?: never;
    url: '/organization/{organization_id}';
};

export type DeleteOrganizationErrors = {
    /**
     * Organization request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Organization not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Organization.
     */
    500: StandardErrorResponse;
};

export type DeleteOrganizationError = DeleteOrganizationErrors[keyof DeleteOrganizationErrors];

export type DeleteOrganizationResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteOrganizationResponse = DeleteOrganizationResponses[keyof DeleteOrganizationResponses];

export type GetOrganizationData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a organization_id
         */
        organization_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for Organization.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Organization are .
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/organization/{organization_id}';
};

export type GetOrganizationErrors = {
    /**
     * Organization request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Organization not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Organization.
     */
    500: StandardErrorResponse;
    /**
     * The top-level container for an organization using ConfigHub.
     */
    default: Organization;
};

export type GetOrganizationError = GetOrganizationErrors[keyof GetOrganizationErrors];

export type GetOrganizationResponses = {
    /**
     * The top-level container for an organization using ConfigHub.
     */
    200: Organization;
};

export type GetOrganizationResponse = GetOrganizationResponses[keyof GetOrganizationResponses];

export type UpdateOrganizationData = {
    body?: Organization;
    path: {
        /**
         * Unique identifier for a organization_id
         */
        organization_id: string;
    };
    query?: never;
    url: '/organization/{organization_id}';
};

export type UpdateOrganizationErrors = {
    /**
     * Organization request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Organization not found.
     */
    404: StandardErrorResponse;
    /**
     * Organization data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing Organization.
     */
    500: StandardErrorResponse;
    /**
     * The top-level container for an organization using ConfigHub.
     */
    default: Organization;
};

export type UpdateOrganizationError = UpdateOrganizationErrors[keyof UpdateOrganizationErrors];

export type UpdateOrganizationResponses = {
    /**
     * The top-level container for an organization using ConfigHub.
     */
    200: Organization;
};

export type UpdateOrganizationResponse = UpdateOrganizationResponses[keyof UpdateOrganizationResponses];

export type GetOrganizationExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a organization_id
         */
        organization_id: string;
    };
    query?: never;
    url: '/organization/{organization_id}/extended';
};

export type GetOrganizationExtendedErrors = {
    /**
     * Organization request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Organization not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Organization.
     */
    500: StandardErrorResponse;
    default: OrganizationExtended;
};

export type GetOrganizationExtendedError = GetOrganizationExtendedErrors[keyof GetOrganizationExtendedErrors];

export type GetOrganizationExtendedResponses = {
    /**
     * OK
     */
    200: OrganizationExtended;
};

export type GetOrganizationExtendedResponse = GetOrganizationExtendedResponses[keyof GetOrganizationExtendedResponses];

export type ListOrganizationMembersData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a organization_id
         */
        organization_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on OrganizationMember: DisplayName, ExternalID, Slug, UserID, Username.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
    };
    url: '/organization/{organization_id}/organization_member';
};

export type ListOrganizationMembersErrors = {
    /**
     * OrganizationMember request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * OrganizationMember not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing OrganizationMember.
     */
    500: StandardErrorResponse;
    default: Array<OrganizationMember>;
};

export type ListOrganizationMembersError = ListOrganizationMembersErrors[keyof ListOrganizationMembersErrors];

export type ListOrganizationMembersResponses = {
    /**
     * OK
     */
    200: Array<OrganizationMember>;
};

export type ListOrganizationMembersResponse = ListOrganizationMembersResponses[keyof ListOrganizationMembersResponses];

export type CreateOrganizationMemberData = {
    body?: OrganizationMember;
    path: {
        /**
         * Unique identifier for a organization_id
         */
        organization_id: string;
    };
    query?: never;
    url: '/organization/{organization_id}/organization_member';
};

export type CreateOrganizationMemberErrors = {
    /**
     * OrganizationMember request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * OrganizationMember not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing OrganizationMember.
     */
    500: StandardErrorResponse;
    /**
     * a User given membership on the Organization
     */
    default: OrganizationMember;
};

export type CreateOrganizationMemberError = CreateOrganizationMemberErrors[keyof CreateOrganizationMemberErrors];

export type CreateOrganizationMemberResponses = {
    /**
     * a User given membership on the Organization
     */
    200: OrganizationMember;
};

export type CreateOrganizationMemberResponse = CreateOrganizationMemberResponses[keyof CreateOrganizationMemberResponses];

export type DeleteOrganizationMemberData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a organization_id
         */
        organization_id: string;
        /**
         * Unique identifier for a organization_member_id
         */
        organization_member_id: string;
    };
    query?: never;
    url: '/organization/{organization_id}/organization_member/{organization_member_id}';
};

export type DeleteOrganizationMemberErrors = {
    /**
     * OrganizationMember request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * OrganizationMember not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing OrganizationMember.
     */
    500: StandardErrorResponse;
};

export type DeleteOrganizationMemberError = DeleteOrganizationMemberErrors[keyof DeleteOrganizationMemberErrors];

export type DeleteOrganizationMemberResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteOrganizationMemberResponse = DeleteOrganizationMemberResponses[keyof DeleteOrganizationMemberResponses];

export type GetOrganizationMemberData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a organization_id
         */
        organization_id: string;
        /**
         * Unique identifier for a organization_member_id
         */
        organization_member_id: string;
    };
    query?: never;
    url: '/organization/{organization_id}/organization_member/{organization_member_id}';
};

export type GetOrganizationMemberErrors = {
    /**
     * OrganizationMember request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * OrganizationMember not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing OrganizationMember.
     */
    500: StandardErrorResponse;
    /**
     * a User given membership on the Organization
     */
    default: OrganizationMember;
};

export type GetOrganizationMemberError = GetOrganizationMemberErrors[keyof GetOrganizationMemberErrors];

export type GetOrganizationMemberResponses = {
    /**
     * a User given membership on the Organization
     */
    200: OrganizationMember;
};

export type GetOrganizationMemberResponse = GetOrganizationMemberResponses[keyof GetOrganizationMemberResponses];

export type ListSpacesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Space: CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Space.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Space are OrganizationID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
        /**
         * Flag parameter for enabling summary
         */
        summary?: boolean;
    };
    url: '/space';
};

export type ListSpacesErrors = {
    /**
     * Space request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Space not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Space.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedSpace>;
};

export type ListSpacesError = ListSpacesErrors[keyof ListSpacesErrors];

export type ListSpacesResponses = {
    /**
     * OK
     */
    200: Array<ExtendedSpace>;
};

export type ListSpacesResponse = ListSpacesResponses[keyof ListSpacesResponses];

export type CreateSpaceData = {
    body?: Space;
    path?: never;
    query?: never;
    url: '/space';
};

export type CreateSpaceErrors = {
    /**
     * Space request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Space not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Space.
     */
    500: StandardErrorResponse;
    /**
     * The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
     */
    default: Space;
};

export type CreateSpaceError = CreateSpaceErrors[keyof CreateSpaceErrors];

export type CreateSpaceResponses = {
    /**
     * The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
     */
    200: Space;
};

export type CreateSpaceResponse = CreateSpaceResponses[keyof CreateSpaceResponses];

export type DeleteSpaceData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: never;
    url: '/space/{space_id}';
};

export type DeleteSpaceErrors = {
    /**
     * Space request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Space not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Space.
     */
    500: StandardErrorResponse;
};

export type DeleteSpaceError = DeleteSpaceErrors[keyof DeleteSpaceErrors];

export type DeleteSpaceResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteSpaceResponse = DeleteSpaceResponses[keyof DeleteSpaceResponses];

export type GetSpaceData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for Space.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Space are OrganizationID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
        /**
         * Flag parameter for enabling summary
         */
        summary?: boolean;
    };
    url: '/space/{space_id}';
};

export type GetSpaceErrors = {
    /**
     * Space request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Space not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Space.
     */
    500: StandardErrorResponse;
    default: ExtendedSpace;
};

export type GetSpaceError = GetSpaceErrors[keyof GetSpaceErrors];

export type GetSpaceResponses = {
    /**
     * OK
     */
    200: ExtendedSpace;
};

export type GetSpaceResponse = GetSpaceResponses[keyof GetSpaceResponses];

export type UpdateSpaceData = {
    body?: Space;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: never;
    url: '/space/{space_id}';
};

export type UpdateSpaceErrors = {
    /**
     * Space request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Space not found.
     */
    404: StandardErrorResponse;
    /**
     * Space data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing Space.
     */
    500: StandardErrorResponse;
    /**
     * The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
     */
    default: Space;
};

export type UpdateSpaceError = UpdateSpaceErrors[keyof UpdateSpaceErrors];

export type UpdateSpaceResponses = {
    /**
     * The logical container for most entities in ConfigHub. Namespaces triggers, units, targets, workers, and other entities.
     */
    200: Space;
};

export type UpdateSpaceResponse = UpdateSpaceResponses[keyof UpdateSpaceResponses];

export type ListBridgeWorkersData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on BridgeWorker: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, Slug, SpaceID, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for BridgeWorker.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for BridgeWorker are OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/bridge_worker';
};

export type ListBridgeWorkersErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedBridgeWorker>;
};

export type ListBridgeWorkersError = ListBridgeWorkersErrors[keyof ListBridgeWorkersErrors];

export type ListBridgeWorkersResponses = {
    /**
     * OK
     */
    200: Array<ExtendedBridgeWorker>;
};

export type ListBridgeWorkersResponse = ListBridgeWorkersResponses[keyof ListBridgeWorkersResponses];

export type CreateBridgeWorkerData = {
    body?: BridgeWorker;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: never;
    url: '/space/{space_id}/bridge_worker';
};

export type CreateBridgeWorkerErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
    /**
     * BridgeWorker represents a bridge worker in ConfigHub.
     * A bridge worker is a worker program that connects ConfigHub to external systems and targets.
     * It acts as a bridge between ConfigHub and the infrastructure where configurations need
     * to be applied. Bridge workers are responsible for executing configuration changes on
     * remote targets and reporting status back to ConfigHub.
     * When starting a bridge worker program, both the BridgeWorkerID and Secret are
     * required for authentication with the ConfigHub server. These credentials allow the
     * bridge worker to establish a secure connection and receive configuration actions.
     */
    default: BridgeWorker;
};

export type CreateBridgeWorkerError = CreateBridgeWorkerErrors[keyof CreateBridgeWorkerErrors];

export type CreateBridgeWorkerResponses = {
    /**
     * BridgeWorker represents a bridge worker in ConfigHub.
     * A bridge worker is a worker program that connects ConfigHub to external systems and targets.
     * It acts as a bridge between ConfigHub and the infrastructure where configurations need
     * to be applied. Bridge workers are responsible for executing configuration changes on
     * remote targets and reporting status back to ConfigHub.
     * When starting a bridge worker program, both the BridgeWorkerID and Secret are
     * required for authentication with the ConfigHub server. These credentials allow the
     * bridge worker to establish a secure connection and receive configuration actions.
     */
    200: BridgeWorker;
};

export type CreateBridgeWorkerResponse = CreateBridgeWorkerResponses[keyof CreateBridgeWorkerResponses];

export type DeleteBridgeWorkerData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: never;
    url: '/space/{space_id}/bridge_worker/{bridge_worker_id}';
};

export type DeleteBridgeWorkerErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
};

export type DeleteBridgeWorkerError = DeleteBridgeWorkerErrors[keyof DeleteBridgeWorkerErrors];

export type DeleteBridgeWorkerResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteBridgeWorkerResponse = DeleteBridgeWorkerResponses[keyof DeleteBridgeWorkerResponses];

export type GetBridgeWorkerData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for BridgeWorker.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for BridgeWorker are OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/bridge_worker/{bridge_worker_id}';
};

export type GetBridgeWorkerErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
    default: ExtendedBridgeWorker;
};

export type GetBridgeWorkerError = GetBridgeWorkerErrors[keyof GetBridgeWorkerErrors];

export type GetBridgeWorkerResponses = {
    /**
     * OK
     */
    200: ExtendedBridgeWorker;
};

export type GetBridgeWorkerResponse = GetBridgeWorkerResponses[keyof GetBridgeWorkerResponses];

export type UpdateBridgeWorkerData = {
    body?: BridgeWorker;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: never;
    url: '/space/{space_id}/bridge_worker/{bridge_worker_id}';
};

export type UpdateBridgeWorkerErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * BridgeWorker data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
    /**
     * BridgeWorker represents a bridge worker in ConfigHub.
     * A bridge worker is a worker program that connects ConfigHub to external systems and targets.
     * It acts as a bridge between ConfigHub and the infrastructure where configurations need
     * to be applied. Bridge workers are responsible for executing configuration changes on
     * remote targets and reporting status back to ConfigHub.
     * When starting a bridge worker program, both the BridgeWorkerID and Secret are
     * required for authentication with the ConfigHub server. These credentials allow the
     * bridge worker to establish a secure connection and receive configuration actions.
     */
    default: BridgeWorker;
};

export type UpdateBridgeWorkerError = UpdateBridgeWorkerErrors[keyof UpdateBridgeWorkerErrors];

export type UpdateBridgeWorkerResponses = {
    /**
     * BridgeWorker represents a bridge worker in ConfigHub.
     * A bridge worker is a worker program that connects ConfigHub to external systems and targets.
     * It acts as a bridge between ConfigHub and the infrastructure where configurations need
     * to be applied. Bridge workers are responsible for executing configuration changes on
     * remote targets and reporting status back to ConfigHub.
     * When starting a bridge worker program, both the BridgeWorkerID and Secret are
     * required for authentication with the ConfigHub server. These credentials allow the
     * bridge worker to establish a secure connection and receive configuration actions.
     */
    200: BridgeWorker;
};

export type UpdateBridgeWorkerResponse = UpdateBridgeWorkerResponses[keyof UpdateBridgeWorkerResponses];

export type GetBridgeWorkerExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: never;
    url: '/space/{space_id}/bridge_worker/{bridge_worker_id}/extended';
};

export type GetBridgeWorkerExtendedErrors = {
    /**
     * BridgeWorker request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorker not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorker.
     */
    500: StandardErrorResponse;
    default: BridgeWorkerExtended;
};

export type GetBridgeWorkerExtendedError = GetBridgeWorkerExtendedErrors[keyof GetBridgeWorkerExtendedErrors];

export type GetBridgeWorkerExtendedResponses = {
    /**
     * OK
     */
    200: BridgeWorkerExtended;
};

export type GetBridgeWorkerExtendedResponse = GetBridgeWorkerExtendedResponses[keyof GetBridgeWorkerExtendedResponses];

export type ListBridgeWorkerFunctionsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: never;
    url: '/space/{space_id}/bridge_worker/{bridge_worker_id}/function';
};

export type ListBridgeWorkerFunctionsErrors = {
    default: {
        [key: string]: {
            [key: string]: FunctionSignature;
        };
    };
};

export type ListBridgeWorkerFunctionsError = ListBridgeWorkerFunctionsErrors[keyof ListBridgeWorkerFunctionsErrors];

export type ListBridgeWorkerFunctionsResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: {
            [key: string]: FunctionSignature;
        };
    };
};

export type ListBridgeWorkerFunctionsResponse = ListBridgeWorkerFunctionsResponses[keyof ListBridgeWorkerFunctionsResponses];

export type ListBridgeWorkerStatusesData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
    };
    query?: never;
    url: '/space/{space_id}/bridge_worker/{bridge_worker_id}/status';
};

export type ListBridgeWorkerStatusesErrors = {
    /**
     * BridgeWorkerStatus request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorkerStatus not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorkerStatus.
     */
    500: StandardErrorResponse;
    default: Array<BridgeWorkerStatus>;
};

export type ListBridgeWorkerStatusesError = ListBridgeWorkerStatusesErrors[keyof ListBridgeWorkerStatusesErrors];

export type ListBridgeWorkerStatusesResponses = {
    /**
     * OK
     */
    200: Array<BridgeWorkerStatus>;
};

export type ListBridgeWorkerStatusesResponse = ListBridgeWorkerStatusesResponses[keyof ListBridgeWorkerStatusesResponses];

export type GetBridgeWorkerStatusData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a bridge_worker_id
         */
        bridge_worker_id: string;
        /**
         * Unique identifier for a status_id
         */
        status_id: string;
    };
    query?: never;
    url: '/space/{space_id}/bridge_worker/{bridge_worker_id}/status/{status_id}';
};

export type GetBridgeWorkerStatusErrors = {
    /**
     * BridgeWorkerStatus request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * BridgeWorkerStatus not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing BridgeWorkerStatus.
     */
    500: StandardErrorResponse;
    /**
     * BridgeWorkerStatus represents the status information of a bridge worker within the system.
     */
    default: BridgeWorkerStatus;
};

export type GetBridgeWorkerStatusError = GetBridgeWorkerStatusErrors[keyof GetBridgeWorkerStatusErrors];

export type GetBridgeWorkerStatusResponses = {
    /**
     * BridgeWorkerStatus represents the status information of a bridge worker within the system.
     */
    200: BridgeWorkerStatus;
};

export type GetBridgeWorkerStatusResponse = GetBridgeWorkerStatusResponses[keyof GetBridgeWorkerStatusResponses];

export type GetSpaceExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: never;
    url: '/space/{space_id}/extended';
};

export type GetSpaceExtendedErrors = {
    /**
     * Space request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Space not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Space.
     */
    500: StandardErrorResponse;
    default: SpaceExtended;
};

export type GetSpaceExtendedError = GetSpaceExtendedErrors[keyof GetSpaceExtendedErrors];

export type GetSpaceExtendedResponses = {
    /**
     * OK
     */
    200: SpaceExtended;
};

export type GetSpaceExtendedResponse = GetSpaceExtendedResponses[keyof GetSpaceExtendedResponses];

export type ListFunctionsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * Type of entity used to identify the worker whose functions should be listed: unit, target, or worker
         */
        entity?: string;
        /**
         * ID of the entity used to identify the worker whose functions should be listed
         */
        id?: string;
    };
    url: '/space/{space_id}/function';
};

export type ListFunctionsErrors = {
    /**
     * Function request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Function not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Function.
     */
    500: StandardErrorResponse;
    default: {
        [key: string]: {
            [key: string]: FunctionSignature;
        };
    };
};

export type ListFunctionsError = ListFunctionsErrors[keyof ListFunctionsErrors];

export type ListFunctionsResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: {
            [key: string]: FunctionSignature;
        };
    };
};

export type ListFunctionsResponse = ListFunctionsResponses[keyof ListFunctionsResponses];

export type InvokeFunctionsData = {
    body?: FunctionInvocationsRequest;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * Unit ID of the Revision to invoke functions on
         */
        unit_id?: string;
        /**
         * Revision ID to invoke functions on instead of units
         */
        revision_id?: string;
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
         *
         * Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
    };
    url: '/space/{space_id}/function/invoke';
};

export type InvokeFunctionsErrors = {
    /**
     * Function request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Function not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Function.
     */
    500: StandardErrorResponse;
    default: Array<FunctionInvocationResponse>;
};

export type InvokeFunctionsError = InvokeFunctionsErrors[keyof InvokeFunctionsErrors];

export type InvokeFunctionsResponses = {
    /**
     * OK
     */
    200: Array<FunctionInvocationResponse>;
};

export type InvokeFunctionsResponse = InvokeFunctionsResponses[keyof InvokeFunctionsResponses];

export type ListLinksData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Link: CreatedAt, DisplayName, FromUnitID, Labels, LinkID, OrganizationID, Slug, SpaceID, ToSpaceID, ToUnitID, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Link.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/link';
};

export type ListLinksErrors = {
    /**
     * Link request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Link not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Link.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedLink>;
};

export type ListLinksError = ListLinksErrors[keyof ListLinksErrors];

export type ListLinksResponses = {
    /**
     * OK
     */
    200: Array<ExtendedLink>;
};

export type ListLinksResponse = ListLinksResponses[keyof ListLinksResponses];

export type CreateLinkData = {
    body?: Link;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: never;
    url: '/space/{space_id}/link';
};

export type CreateLinkErrors = {
    /**
     * Link request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Link not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Link.
     */
    500: StandardErrorResponse;
    /**
     * Link connects two config Units in a dependency / producer-consumer relationship.
     * A Link indicates that config values Provided by the To Unit (the producer) may
     * satisfy config values Needed by the From Unit (the consumer), and should be attempted
     * to be matched before values Provided by other Units in the Space (if within the same
     * Space). Links must be created in the same Space as the From Unit.
     * They also imply an ordering when Applied or Destroyed as a Set.
     */
    default: Link;
};

export type CreateLinkError = CreateLinkErrors[keyof CreateLinkErrors];

export type CreateLinkResponses = {
    /**
     * Link connects two config Units in a dependency / producer-consumer relationship.
     * A Link indicates that config values Provided by the To Unit (the producer) may
     * satisfy config values Needed by the From Unit (the consumer), and should be attempted
     * to be matched before values Provided by other Units in the Space (if within the same
     * Space). Links must be created in the same Space as the From Unit.
     * They also imply an ordering when Applied or Destroyed as a Set.
     */
    200: Link;
};

export type CreateLinkResponse = CreateLinkResponses[keyof CreateLinkResponses];

export type DeleteLinkData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a link_id
         */
        link_id: string;
    };
    query?: never;
    url: '/space/{space_id}/link/{link_id}';
};

export type DeleteLinkErrors = {
    /**
     * Link request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Link not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Link.
     */
    500: StandardErrorResponse;
};

export type DeleteLinkError = DeleteLinkErrors[keyof DeleteLinkErrors];

export type DeleteLinkResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteLinkResponse = DeleteLinkResponses[keyof DeleteLinkResponses];

export type GetLinkData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a link_id
         */
        link_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for Link.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Link are FromUnitID, OrganizationID, SpaceID, ToSpaceID, ToUnitID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/link/{link_id}';
};

export type GetLinkErrors = {
    /**
     * Link request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Link not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Link.
     */
    500: StandardErrorResponse;
    default: ExtendedLink;
};

export type GetLinkError = GetLinkErrors[keyof GetLinkErrors];

export type GetLinkResponses = {
    /**
     * OK
     */
    200: ExtendedLink;
};

export type GetLinkResponse = GetLinkResponses[keyof GetLinkResponses];

export type UpdateLinkData = {
    body?: Link;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a link_id
         */
        link_id: string;
    };
    query?: never;
    url: '/space/{space_id}/link/{link_id}';
};

export type UpdateLinkErrors = {
    /**
     * Link request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Link not found.
     */
    404: StandardErrorResponse;
    /**
     * Link data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing Link.
     */
    500: StandardErrorResponse;
    /**
     * Link connects two config Units in a dependency / producer-consumer relationship.
     * A Link indicates that config values Provided by the To Unit (the producer) may
     * satisfy config values Needed by the From Unit (the consumer), and should be attempted
     * to be matched before values Provided by other Units in the Space (if within the same
     * Space). Links must be created in the same Space as the From Unit.
     * They also imply an ordering when Applied or Destroyed as a Set.
     */
    default: Link;
};

export type UpdateLinkError = UpdateLinkErrors[keyof UpdateLinkErrors];

export type UpdateLinkResponses = {
    /**
     * Link connects two config Units in a dependency / producer-consumer relationship.
     * A Link indicates that config values Provided by the To Unit (the producer) may
     * satisfy config values Needed by the From Unit (the consumer), and should be attempted
     * to be matched before values Provided by other Units in the Space (if within the same
     * Space). Links must be created in the same Space as the From Unit.
     * They also imply an ordering when Applied or Destroyed as a Set.
     */
    200: Link;
};

export type UpdateLinkResponse = UpdateLinkResponses[keyof UpdateLinkResponses];

export type GetLinkExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a link_id
         */
        link_id: string;
    };
    query?: never;
    url: '/space/{space_id}/link/{link_id}/extended';
};

export type GetLinkExtendedErrors = {
    /**
     * Link request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Link not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Link.
     */
    500: StandardErrorResponse;
    default: LinkExtended;
};

export type GetLinkExtendedError = GetLinkExtendedErrors[keyof GetLinkExtendedErrors];

export type GetLinkExtendedResponses = {
    /**
     * OK
     */
    200: LinkExtended;
};

export type GetLinkExtendedResponse = GetLinkExtendedResponses[keyof GetLinkExtendedResponses];

export type ListSetsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Set: CreatedAt, DisplayName, Labels, OrganizationID, SetID, Slug, SpaceID, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Set.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Set are OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/set';
};

export type ListSetsErrors = {
    /**
     * Set request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Set not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Set.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedSet>;
};

export type ListSetsError = ListSetsErrors[keyof ListSetsErrors];

export type ListSetsResponses = {
    /**
     * OK
     */
    200: Array<ExtendedSet>;
};

export type ListSetsResponse = ListSetsResponses[keyof ListSetsResponses];

export type CreateSetData = {
    body?: _Set;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: never;
    url: '/space/{space_id}/set';
};

export type CreateSetErrors = {
    /**
     * Set request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Set not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Set.
     */
    500: StandardErrorResponse;
    /**
     * A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
     */
    default: _Set;
};

export type CreateSetError = CreateSetErrors[keyof CreateSetErrors];

export type CreateSetResponses = {
    /**
     * A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
     */
    200: _Set;
};

export type CreateSetResponse = CreateSetResponses[keyof CreateSetResponses];

export type DeleteSetData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a set_id
         */
        set_id: string;
    };
    query?: never;
    url: '/space/{space_id}/set/{set_id}';
};

export type DeleteSetErrors = {
    /**
     * Set request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Set not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Set.
     */
    500: StandardErrorResponse;
};

export type DeleteSetError = DeleteSetErrors[keyof DeleteSetErrors];

export type DeleteSetResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteSetResponse = DeleteSetResponses[keyof DeleteSetResponses];

export type GetSetData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a set_id
         */
        set_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for Set.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Set are OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/set/{set_id}';
};

export type GetSetErrors = {
    /**
     * Set request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Set not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Set.
     */
    500: StandardErrorResponse;
    default: ExtendedSet;
};

export type GetSetError = GetSetErrors[keyof GetSetErrors];

export type GetSetResponses = {
    /**
     * OK
     */
    200: ExtendedSet;
};

export type GetSetResponse = GetSetResponses[keyof GetSetResponses];

export type UpdateSetData = {
    body?: _Set;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a set_id
         */
        set_id: string;
    };
    query?: never;
    url: '/space/{space_id}/set/{set_id}';
};

export type UpdateSetErrors = {
    /**
     * Set request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Set not found.
     */
    404: StandardErrorResponse;
    /**
     * Set data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing Set.
     */
    500: StandardErrorResponse;
    /**
     * A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
     */
    default: _Set;
};

export type UpdateSetError = UpdateSetErrors[keyof UpdateSetErrors];

export type UpdateSetResponses = {
    /**
     * A group of related Units that can be cloned, upgraded, applied, refreshed, or destroyed as a group.
     */
    200: _Set;
};

export type UpdateSetResponse = UpdateSetResponses[keyof UpdateSetResponses];

export type GetSetExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a set_id
         */
        set_id: string;
    };
    query?: never;
    url: '/space/{space_id}/set/{set_id}/extended';
};

export type GetSetExtendedErrors = {
    /**
     * Set request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Set not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Set.
     */
    500: StandardErrorResponse;
    default: SetExtended;
};

export type GetSetExtendedError = GetSetExtendedErrors[keyof GetSetExtendedErrors];

export type GetSetExtendedResponses = {
    /**
     * OK
     */
    200: SetExtended;
};

export type GetSetExtendedResponse = GetSetExtendedResponses[keyof GetSetExtendedResponses];

export type ListTargetsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Target.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/target';
};

export type ListTargetsErrors = {
    /**
     * Target request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Target not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Target.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedTarget>;
};

export type ListTargetsError = ListTargetsErrors[keyof ListTargetsErrors];

export type ListTargetsResponses = {
    /**
     * OK
     */
    200: Array<ExtendedTarget>;
};

export type ListTargetsResponse = ListTargetsResponses[keyof ListTargetsResponses];

export type CreateTargetData = {
    body?: Target;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: never;
    url: '/space/{space_id}/target';
};

export type CreateTargetErrors = {
    /**
     * Target request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Target not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Target.
     */
    500: StandardErrorResponse;
    /**
     * Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
     */
    default: Target;
};

export type CreateTargetError = CreateTargetErrors[keyof CreateTargetErrors];

export type CreateTargetResponses = {
    /**
     * Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
     */
    200: Target;
};

export type CreateTargetResponse = CreateTargetResponses[keyof CreateTargetResponses];

export type DeleteTargetData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a target_id
         */
        target_id: string;
    };
    query?: never;
    url: '/space/{space_id}/target/{target_id}';
};

export type DeleteTargetErrors = {
    /**
     * Target request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Target not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Target.
     */
    500: StandardErrorResponse;
};

export type DeleteTargetError = DeleteTargetErrors[keyof DeleteTargetErrors];

export type DeleteTargetResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteTargetResponse = DeleteTargetResponses[keyof DeleteTargetResponses];

export type GetTargetData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a target_id
         */
        target_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for Target.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/target/{target_id}';
};

export type GetTargetErrors = {
    /**
     * Target request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Target not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Target.
     */
    500: StandardErrorResponse;
    default: ExtendedTarget;
};

export type GetTargetError = GetTargetErrors[keyof GetTargetErrors];

export type GetTargetResponses = {
    /**
     * OK
     */
    200: ExtendedTarget;
};

export type GetTargetResponse = GetTargetResponses[keyof GetTargetResponses];

export type UpdateTargetData = {
    body?: Target;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a target_id
         */
        target_id: string;
    };
    query?: never;
    url: '/space/{space_id}/target/{target_id}';
};

export type UpdateTargetErrors = {
    /**
     * Target request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Target not found.
     */
    404: StandardErrorResponse;
    /**
     * Target data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing Target.
     */
    500: StandardErrorResponse;
    /**
     * Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
     */
    default: Target;
};

export type UpdateTargetError = UpdateTargetErrors[keyof UpdateTargetErrors];

export type UpdateTargetResponses = {
    /**
     * Target represents a deployment target in ConfigHub. It defines where configuration should be applied, including the toolchain type (e.g., Kubernetes/YAML, OpenTofu/HCL, AppConfig/Properties) and provider (e.g., AWS, Kubernetes, FluxOCI). Each Target is associated with a specific BridgeWorker that handles the actual deployment actions (e.g. Apply, Destroy).
     */
    200: Target;
};

export type UpdateTargetResponse = UpdateTargetResponses[keyof UpdateTargetResponses];

export type GetTargetExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a target_id
         */
        target_id: string;
    };
    query?: never;
    url: '/space/{space_id}/target/{target_id}/extended';
};

export type GetTargetExtendedErrors = {
    /**
     * Target request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Target not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Target.
     */
    500: StandardErrorResponse;
    default: TargetExtended;
};

export type GetTargetExtendedError = GetTargetExtendedErrors[keyof GetTargetExtendedErrors];

export type GetTargetExtendedResponses = {
    /**
     * OK
     */
    200: TargetExtended;
};

export type GetTargetExtendedResponse = GetTargetExtendedResponses[keyof GetTargetExtendedResponses];

export type ListTriggersData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Trigger: BridgeWorkerID, CreatedAt, Disabled, DisplayName, Enforced, Event, FunctionName, Labels, OrganizationID, Slug, SpaceID, ToolchainType, TriggerID, UpdatedAt, Validating.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Trigger.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Trigger are BridgeWorkerID, OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/trigger';
};

export type ListTriggersErrors = {
    /**
     * Trigger request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Trigger not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Trigger.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedTrigger>;
};

export type ListTriggersError = ListTriggersErrors[keyof ListTriggersErrors];

export type ListTriggersResponses = {
    /**
     * OK
     */
    200: Array<ExtendedTrigger>;
};

export type ListTriggersResponse = ListTriggersResponses[keyof ListTriggersResponses];

export type CreateTriggerData = {
    body?: Trigger;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: never;
    url: '/space/{space_id}/trigger';
};

export type CreateTriggerErrors = {
    /**
     * Trigger request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Trigger not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Trigger.
     */
    500: StandardErrorResponse;
    /**
     * Defines an automated function invocation that executes in response to specific
     * Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
     * automated transformations, or other custom logic that should run when configuration
     * changes occur. Each Trigger is associated with a specific Space and can be configured
     * to execute on events.
     *
     * Triggers can be either validating (checking configuration validity without modifying it)
     * or mutating (making changes to the configuration). They can also be enforced (cannot be
     * overridden) or disabled.
     */
    default: Trigger;
};

export type CreateTriggerError = CreateTriggerErrors[keyof CreateTriggerErrors];

export type CreateTriggerResponses = {
    /**
     * Defines an automated function invocation that executes in response to specific
     * Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
     * automated transformations, or other custom logic that should run when configuration
     * changes occur. Each Trigger is associated with a specific Space and can be configured
     * to execute on events.
     *
     * Triggers can be either validating (checking configuration validity without modifying it)
     * or mutating (making changes to the configuration). They can also be enforced (cannot be
     * overridden) or disabled.
     */
    200: Trigger;
};

export type CreateTriggerResponse = CreateTriggerResponses[keyof CreateTriggerResponses];

export type DeleteTriggerData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a trigger_id
         */
        trigger_id: string;
    };
    query?: never;
    url: '/space/{space_id}/trigger/{trigger_id}';
};

export type DeleteTriggerErrors = {
    /**
     * Trigger request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Trigger not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Trigger.
     */
    500: StandardErrorResponse;
};

export type DeleteTriggerError = DeleteTriggerErrors[keyof DeleteTriggerErrors];

export type DeleteTriggerResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteTriggerResponse = DeleteTriggerResponses[keyof DeleteTriggerResponses];

export type GetTriggerData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a trigger_id
         */
        trigger_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for Trigger.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Trigger are BridgeWorkerID, OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/trigger/{trigger_id}';
};

export type GetTriggerErrors = {
    /**
     * Trigger request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Trigger not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Trigger.
     */
    500: StandardErrorResponse;
    default: ExtendedTrigger;
};

export type GetTriggerError = GetTriggerErrors[keyof GetTriggerErrors];

export type GetTriggerResponses = {
    /**
     * OK
     */
    200: ExtendedTrigger;
};

export type GetTriggerResponse = GetTriggerResponses[keyof GetTriggerResponses];

export type UpdateTriggerData = {
    body?: Trigger;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a trigger_id
         */
        trigger_id: string;
    };
    query?: never;
    url: '/space/{space_id}/trigger/{trigger_id}';
};

export type UpdateTriggerErrors = {
    /**
     * Trigger request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Trigger not found.
     */
    404: StandardErrorResponse;
    /**
     * Trigger data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing Trigger.
     */
    500: StandardErrorResponse;
    /**
     * Defines an automated function invocation that executes in response to specific
     * Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
     * automated transformations, or other custom logic that should run when configuration
     * changes occur. Each Trigger is associated with a specific Space and can be configured
     * to execute on events.
     *
     * Triggers can be either validating (checking configuration validity without modifying it)
     * or mutating (making changes to the configuration). They can also be enforced (cannot be
     * overridden) or disabled.
     */
    default: Trigger;
};

export type UpdateTriggerError = UpdateTriggerErrors[keyof UpdateTriggerErrors];

export type UpdateTriggerResponses = {
    /**
     * Defines an automated function invocation that executes in response to specific
     * Unit lifecycle events in ConfigHub. Triggers can be used to implement validation rules,
     * automated transformations, or other custom logic that should run when configuration
     * changes occur. Each Trigger is associated with a specific Space and can be configured
     * to execute on events.
     *
     * Triggers can be either validating (checking configuration validity without modifying it)
     * or mutating (making changes to the configuration). They can also be enforced (cannot be
     * overridden) or disabled.
     */
    200: Trigger;
};

export type UpdateTriggerResponse = UpdateTriggerResponses[keyof UpdateTriggerResponses];

export type GetTriggerExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a trigger_id
         */
        trigger_id: string;
    };
    query?: never;
    url: '/space/{space_id}/trigger/{trigger_id}/extended';
};

export type GetTriggerExtendedErrors = {
    /**
     * Trigger request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Trigger not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Trigger.
     */
    500: StandardErrorResponse;
    default: TriggerExtended;
};

export type GetTriggerExtendedError = GetTriggerExtendedErrors[keyof GetTriggerExtendedErrors];

export type GetTriggerExtendedResponses = {
    /**
     * OK
     */
    200: TriggerExtended;
};

export type GetTriggerExtendedResponse = GetTriggerExtendedResponses[keyof GetTriggerExtendedResponses];

export type ListUnitsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
         *
         * Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Unit.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/unit';
};

export type ListUnitsErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    default: Array<Unit>;
};

export type ListUnitsError = ListUnitsErrors[keyof ListUnitsErrors];

export type ListUnitsResponses = {
    /**
     * OK
     */
    200: Array<Unit>;
};

export type ListUnitsResponse = ListUnitsResponses[keyof ListUnitsResponses];

export type CreateUnitData = {
    body?: Unit;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * Unique identifier for a upstream_space_id
         */
        upstream_space_id?: string;
        /**
         * Unique identifier for a upstream_unit_id
         */
        upstream_unit_id?: string;
    };
    url: '/space/{space_id}/unit';
};

export type CreateUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    /**
     * Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
     * of a single supported Toolchain Type (congifuration format). This blob is typically a text document
     * that contains a collection of Kubernetes or infrastructure resources, or an application configuration
     * file. Applying / deploying or destroying the configuration happens as a single "transaction"
     * from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
     * the underlying configuration / deployment tool. The resources must belong to a single
     * infrastructure provider and the actuation mechanism must be able to resolve references and
     * ordering dependencies among the resources within the document. For example, if one resource
     * needs to be fully provisioned to provide input to another resource, then the actuation code is
     * responsible for handling this. Revisions store historical copies of the configuration data.
     * Configuration data can be restored from prior Revisions. Units can also be cloned to create
     * new variants of a configuration.
     */
    default: Unit;
};

export type CreateUnitError = CreateUnitErrors[keyof CreateUnitErrors];

export type CreateUnitResponses = {
    /**
     * Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
     * of a single supported Toolchain Type (congifuration format). This blob is typically a text document
     * that contains a collection of Kubernetes or infrastructure resources, or an application configuration
     * file. Applying / deploying or destroying the configuration happens as a single "transaction"
     * from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
     * the underlying configuration / deployment tool. The resources must belong to a single
     * infrastructure provider and the actuation mechanism must be able to resolve references and
     * ordering dependencies among the resources within the document. For example, if one resource
     * needs to be fully provisioned to provide input to another resource, then the actuation code is
     * responsible for handling this. Revisions store historical copies of the configuration data.
     * Configuration data can be restored from prior Revisions. Units can also be cloned to create
     * new variants of a configuration.
     */
    200: Unit;
};

export type CreateUnitResponse = CreateUnitResponses[keyof CreateUnitResponses];

export type ListExtendedUnitsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
         *
         * Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Unit.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/unit/extended';
};

export type ListExtendedUnitsErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedUnit>;
};

export type ListExtendedUnitsError = ListExtendedUnitsErrors[keyof ListExtendedUnitsErrors];

export type ListExtendedUnitsResponses = {
    /**
     * OK
     */
    200: Array<ExtendedUnit>;
};

export type ListExtendedUnitsResponse = ListExtendedUnitsResponses[keyof ListExtendedUnitsResponses];

export type DeleteUnitData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}';
};

export type DeleteUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
};

export type DeleteUnitError = DeleteUnitErrors[keyof DeleteUnitErrors];

export type DeleteUnitResponses = {
    /**
     * Response for successful delete operation
     */
    200: DeleteResponse;
    /**
     * Response for successful delete operation
     */
    default: DeleteResponse;
};

export type DeleteUnitResponse = DeleteUnitResponses[keyof DeleteUnitResponses];

export type GetUnitData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}';
};

export type GetUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    /**
     * Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
     * of a single supported Toolchain Type (congifuration format). This blob is typically a text document
     * that contains a collection of Kubernetes or infrastructure resources, or an application configuration
     * file. Applying / deploying or destroying the configuration happens as a single "transaction"
     * from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
     * the underlying configuration / deployment tool. The resources must belong to a single
     * infrastructure provider and the actuation mechanism must be able to resolve references and
     * ordering dependencies among the resources within the document. For example, if one resource
     * needs to be fully provisioned to provide input to another resource, then the actuation code is
     * responsible for handling this. Revisions store historical copies of the configuration data.
     * Configuration data can be restored from prior Revisions. Units can also be cloned to create
     * new variants of a configuration.
     */
    default: Unit;
};

export type GetUnitError = GetUnitErrors[keyof GetUnitErrors];

export type GetUnitResponses = {
    /**
     * Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
     * of a single supported Toolchain Type (congifuration format). This blob is typically a text document
     * that contains a collection of Kubernetes or infrastructure resources, or an application configuration
     * file. Applying / deploying or destroying the configuration happens as a single "transaction"
     * from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
     * the underlying configuration / deployment tool. The resources must belong to a single
     * infrastructure provider and the actuation mechanism must be able to resolve references and
     * ordering dependencies among the resources within the document. For example, if one resource
     * needs to be fully provisioned to provide input to another resource, then the actuation code is
     * responsible for handling this. Revisions store historical copies of the configuration data.
     * Configuration data can be restored from prior Revisions. Units can also be cloned to create
     * new variants of a configuration.
     */
    200: Unit;
};

export type GetUnitResponse = GetUnitResponses[keyof GetUnitResponses];

export type UpdateUnitData = {
    body?: Unit;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: {
        /**
         * Unique identifier for a revision_id
         */
        revision_id?: string;
        /**
         * Flag parameter for enabling upgrade
         */
        upgrade?: boolean;
    };
    url: '/space/{space_id}/unit/{unit_id}';
};

export type UpdateUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Unit data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    /**
     * Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
     * of a single supported Toolchain Type (congifuration format). This blob is typically a text document
     * that contains a collection of Kubernetes or infrastructure resources, or an application configuration
     * file. Applying / deploying or destroying the configuration happens as a single "transaction"
     * from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
     * the underlying configuration / deployment tool. The resources must belong to a single
     * infrastructure provider and the actuation mechanism must be able to resolve references and
     * ordering dependencies among the resources within the document. For example, if one resource
     * needs to be fully provisioned to provide input to another resource, then the actuation code is
     * responsible for handling this. Revisions store historical copies of the configuration data.
     * Configuration data can be restored from prior Revisions. Units can also be cloned to create
     * new variants of a configuration.
     */
    default: Unit;
};

export type UpdateUnitError = UpdateUnitErrors[keyof UpdateUnitErrors];

export type UpdateUnitResponses = {
    /**
     * Unit is the core unit of operation in ConfigHub. It contains a blob of configuration Data
     * of a single supported Toolchain Type (congifuration format). This blob is typically a text document
     * that contains a collection of Kubernetes or infrastructure resources, or an application configuration
     * file. Applying / deploying or destroying the configuration happens as a single "transaction"
     * from ConfigHub's perspective. In reality, it is most often a multi-step workflow performed by
     * the underlying configuration / deployment tool. The resources must belong to a single
     * infrastructure provider and the actuation mechanism must be able to resolve references and
     * ordering dependencies among the resources within the document. For example, if one resource
     * needs to be fully provisioned to provide input to another resource, then the actuation code is
     * responsible for handling this. Revisions store historical copies of the configuration data.
     * Configuration data can be restored from prior Revisions. Units can also be cloned to create
     * new variants of a configuration.
     */
    200: Unit;
};

export type UpdateUnitResponse = UpdateUnitResponses[keyof UpdateUnitResponses];

export type ApplyUnitData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/apply';
};

export type ApplyUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    /**
     * QueuedOperation is a record of an operation to be done by a bridge worker.
     */
    default: QueuedOperation;
};

export type ApplyUnitError = ApplyUnitErrors[keyof ApplyUnitErrors];

export type ApplyUnitResponses = {
    /**
     * QueuedOperation is a record of an operation to be done by a bridge worker.
     */
    200: QueuedOperation;
};

export type ApplyUnitResponse = ApplyUnitResponses[keyof ApplyUnitResponses];

export type ApproveUnitData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/approve';
};

export type ApproveUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    default: string;
};

export type ApproveUnitError = ApproveUnitErrors[keyof ApproveUnitErrors];

export type ApproveUnitResponses = {
    /**
     * OK
     */
    200: string;
};

export type ApproveUnitResponse = ApproveUnitResponses[keyof ApproveUnitResponses];

export type DestroyUnitData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/destroy';
};

export type DestroyUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    /**
     * QueuedOperation is a record of an operation to be done by a bridge worker.
     */
    default: QueuedOperation;
};

export type DestroyUnitError = DestroyUnitErrors[keyof DestroyUnitErrors];

export type DestroyUnitResponses = {
    /**
     * QueuedOperation is a record of an operation to be done by a bridge worker.
     */
    200: QueuedOperation;
};

export type DestroyUnitResponse = DestroyUnitResponses[keyof DestroyUnitResponses];

export type GetUnitExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/extended';
};

export type GetUnitExtendedErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    default: UnitExtended;
};

export type GetUnitExtendedError = GetUnitExtendedErrors[keyof GetUnitExtendedErrors];

export type GetUnitExtendedResponses = {
    /**
     * OK
     */
    200: UnitExtended;
};

export type GetUnitExtendedResponse = GetUnitExtendedResponses[keyof GetUnitExtendedResponses];

export type ImportUnitData = {
    body?: ImportRequest;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/import';
};

export type ImportUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    /**
     * QueuedOperation is a record of an operation to be done by a bridge worker.
     */
    default: QueuedOperation;
};

export type ImportUnitError = ImportUnitErrors[keyof ImportUnitErrors];

export type ImportUnitResponses = {
    /**
     * QueuedOperation is a record of an operation to be done by a bridge worker.
     */
    200: QueuedOperation;
};

export type ImportUnitResponse = ImportUnitResponses[keyof ImportUnitResponses];

export type DownloadLiveStateUnitData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/live-state';
};

export type DownloadLiveStateUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    default: string;
};

export type DownloadLiveStateUnitError = DownloadLiveStateUnitErrors[keyof DownloadLiveStateUnitErrors];

export type DownloadLiveStateUnitResponses = {
    /**
     * OK
     */
    200: string;
};

export type DownloadLiveStateUnitResponse = DownloadLiveStateUnitResponses[keyof DownloadLiveStateUnitResponses];

export type ListExtendedMutationsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Mutation: CreatedAt, FunctionName, LinkID, MutationID, MutationNum, OrganizationID, RevisionID, RevisionNum, SpaceID, TriggerID, UnitID, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Mutation.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Mutation are LinkID, OrganizationID, RevisionID, SpaceID, TriggerID, UnitID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/unit/{unit_id}/mutation';
};

export type ListExtendedMutationsErrors = {
    /**
     * ExtendedMutation request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * ExtendedMutation not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing ExtendedMutation.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedMutation>;
};

export type ListExtendedMutationsError = ListExtendedMutationsErrors[keyof ListExtendedMutationsErrors];

export type ListExtendedMutationsResponses = {
    /**
     * OK
     */
    200: Array<ExtendedMutation>;
};

export type ListExtendedMutationsResponse = ListExtendedMutationsResponses[keyof ListExtendedMutationsResponses];

export type GetExtendedMutationData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
        /**
         * Unique identifier for a mutation_id
         */
        mutation_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for Mutation.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Mutation are LinkID, OrganizationID, RevisionID, SpaceID, TriggerID, UnitID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/unit/{unit_id}/mutation/{mutation_id}';
};

export type GetExtendedMutationErrors = {
    /**
     * ExtendedMutation request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * ExtendedMutation not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing ExtendedMutation.
     */
    500: StandardErrorResponse;
    default: ExtendedMutation;
};

export type GetExtendedMutationError = GetExtendedMutationErrors[keyof GetExtendedMutationErrors];

export type GetExtendedMutationResponses = {
    /**
     * OK
     */
    200: ExtendedMutation;
};

export type GetExtendedMutationResponse = GetExtendedMutationResponses[keyof GetExtendedMutationResponses];

export type GetMutationExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
        /**
         * Unique identifier for a mutation_id
         */
        mutation_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/mutation/{mutation_id}/extended';
};

export type GetMutationExtendedErrors = {
    /**
     * Mutation request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Mutation not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Mutation.
     */
    500: StandardErrorResponse;
    default: MutationExtended;
};

export type GetMutationExtendedError = GetMutationExtendedErrors[keyof GetMutationExtendedErrors];

export type GetMutationExtendedResponses = {
    /**
     * OK
     */
    200: MutationExtended;
};

export type GetMutationExtendedResponse = GetMutationExtendedResponses[keyof GetMutationExtendedResponses];

export type RefreshUnitData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/refresh';
};

export type RefreshUnitErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    /**
     * QueuedOperation is a record of an operation to be done by a bridge worker.
     */
    default: QueuedOperation;
};

export type RefreshUnitError = RefreshUnitErrors[keyof RefreshUnitErrors];

export type RefreshUnitResponses = {
    /**
     * QueuedOperation is a record of an operation to be done by a bridge worker.
     */
    200: QueuedOperation;
};

export type RefreshUnitResponse = RefreshUnitResponses[keyof RefreshUnitResponses];

export type ListExtendedRevisionsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Revision: ApplyGates, ApprovedBy, CreatedAt, Description, LiveAt, OrganizationID, RevisionID, RevisionNum, Source, SpaceID, UnitID, UpdatedAt, UserAgent, UserID.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Revision.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Revision are OrganizationID, SpaceID, UnitID, UserID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/unit/{unit_id}/revision';
};

export type ListExtendedRevisionsErrors = {
    /**
     * ExtendedRevision request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * ExtendedRevision not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing ExtendedRevision.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedRevision>;
};

export type ListExtendedRevisionsError = ListExtendedRevisionsErrors[keyof ListExtendedRevisionsErrors];

export type ListExtendedRevisionsResponses = {
    /**
     * OK
     */
    200: Array<ExtendedRevision>;
};

export type ListExtendedRevisionsResponse = ListExtendedRevisionsResponses[keyof ListExtendedRevisionsResponses];

export type GetExtendedRevisionData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
        /**
         * Unique identifier for a revision_id
         */
        revision_id: string;
    };
    query?: {
        /**
         * Include clause for expanding related entities in the response for Revision.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Revision are OrganizationID, SpaceID, UnitID, UserID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/space/{space_id}/unit/{unit_id}/revision/{revision_id}';
};

export type GetExtendedRevisionErrors = {
    /**
     * ExtendedRevision request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * ExtendedRevision not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing ExtendedRevision.
     */
    500: StandardErrorResponse;
    default: ExtendedRevision;
};

export type GetExtendedRevisionError = GetExtendedRevisionErrors[keyof GetExtendedRevisionErrors];

export type GetExtendedRevisionResponses = {
    /**
     * OK
     */
    200: ExtendedRevision;
};

export type GetExtendedRevisionResponse = GetExtendedRevisionResponses[keyof GetExtendedRevisionResponses];

export type GetRevisionDataData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
        /**
         * Unique identifier for a revision_id
         */
        revision_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/revision/{revision_id}/data';
};

export type GetRevisionDataErrors = {
    /**
     * Revision request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Revision not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Revision.
     */
    500: StandardErrorResponse;
    default: Blob | File;
};

export type GetRevisionDataError = GetRevisionDataErrors[keyof GetRevisionDataErrors];

export type GetRevisionDataResponses = {
    /**
     * OK
     */
    200: Blob | File;
};

export type GetRevisionDataResponse = GetRevisionDataResponses[keyof GetRevisionDataResponses];

export type GetRevisionExtendedData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
        /**
         * Unique identifier for a revision_id
         */
        revision_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/revision/{revision_id}/extended';
};

export type GetRevisionExtendedErrors = {
    /**
     * Revision request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Revision not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Revision.
     */
    500: StandardErrorResponse;
    default: RevisionExtended;
};

export type GetRevisionExtendedError = GetRevisionExtendedErrors[keyof GetRevisionExtendedErrors];

export type GetRevisionExtendedResponses = {
    /**
     * OK
     */
    200: RevisionExtended;
};

export type GetRevisionExtendedResponse = GetRevisionExtendedResponses[keyof GetRevisionExtendedResponses];

export type ListUnitEventsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on UnitEvent: Action, CreatedAt, OrganizationID, QueuedOperationID, Result, RevisionNum, SpaceID, StartedAt, Status, TerminatedAt, UnitEventID, UnitID, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
    };
    url: '/space/{space_id}/unit/{unit_id}/unit_event';
};

export type ListUnitEventsErrors = {
    /**
     * UnitEvent request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * UnitEvent not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing UnitEvent.
     */
    500: StandardErrorResponse;
    default: Array<UnitEvent>;
};

export type ListUnitEventsError = ListUnitEventsErrors[keyof ListUnitEventsErrors];

export type ListUnitEventsResponses = {
    /**
     * OK
     */
    200: Array<UnitEvent>;
};

export type ListUnitEventsResponse = ListUnitEventsResponses[keyof ListUnitEventsResponses];

export type GetUnitEventData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
        /**
         * Unique identifier for a unit_event_id
         */
        unit_event_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/unit_event/{unit_event_id}';
};

export type GetUnitEventErrors = {
    /**
     * UnitEvent request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * UnitEvent not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing UnitEvent.
     */
    500: StandardErrorResponse;
    /**
     * UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks
     * the lifecycle of applying, destroying, or refreshing a Unit's configuration in the target
     * live system. The event captures the current status of the operation, any configuration
     * drift detected, and timing information about when the action started and completed.
     * Actions are atomic from ConfigHub's perspective but may involve multiple steps
     * in the connected Bridge. The status and drift detection help track the health
     * and consistency of the provisioned configuration compared to what is defined in the Unit.
     */
    default: UnitEvent;
};

export type GetUnitEventError = GetUnitEventErrors[keyof GetUnitEventErrors];

export type GetUnitEventResponses = {
    /**
     * UnitEvent represents an event of action performed on a Unit's configuration. Each action tracks
     * the lifecycle of applying, destroying, or refreshing a Unit's configuration in the target
     * live system. The event captures the current status of the operation, any configuration
     * drift detected, and timing information about when the action started and completed.
     * Actions are atomic from ConfigHub's perspective but may involve multiple steps
     * in the connected Bridge. The status and drift detection help track the health
     * and consistency of the provisioned configuration compared to what is defined in the Unit.
     */
    200: UnitEvent;
};

export type GetUnitEventResponse = GetUnitEventResponses[keyof GetUnitEventResponses];

export type UpgradeDownstreamUnitsData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a space_id
         */
        space_id: string;
        /**
         * Unique identifier for a unit_id
         */
        unit_id: string;
    };
    query?: never;
    url: '/space/{space_id}/unit/{unit_id}/upgrade';
};

export type UpgradeDownstreamUnitsErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Unit data conflict. Data has changed since last read.
     */
    409: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    default: UpgradeUnitResponse;
};

export type UpgradeDownstreamUnitsError = UpgradeDownstreamUnitsErrors[keyof UpgradeDownstreamUnitsErrors];

export type UpgradeDownstreamUnitsResponses = {
    /**
     * OK
     */
    200: UpgradeUnitResponse;
};

export type UpgradeDownstreamUnitsResponse = UpgradeDownstreamUnitsResponses[keyof UpgradeDownstreamUnitsResponses];

export type ListAllTargetsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Target: BridgeWorkerID, CreatedAt, DisplayName, Labels, OrganizationID, ProviderType, Slug, SpaceID, TargetID, ToolchainType, UpdatedAt.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Target.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Target are BridgeWorkerID, OrganizationID, SpaceID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
    };
    url: '/target';
};

export type ListAllTargetsErrors = {
    /**
     * Target request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Target not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Target.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedTarget>;
};

export type ListAllTargetsError = ListAllTargetsErrors[keyof ListAllTargetsErrors];

export type ListAllTargetsResponses = {
    /**
     * OK
     */
    200: Array<ExtendedTarget>;
};

export type ListAllTargetsResponse = ListAllTargetsResponses[keyof ListAllTargetsResponses];

export type ListAllUnitsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on Unit: ApplyGates, ApprovedBy, CreatedAt, DisplayName, HeadRevisionNum, Labels, LastActionAt, LastAppliedRevisionNum, LastChangeDescription, LiveRevisionNum, OrganizationID, PreviousLiveRevisionNum, SetID, Slug, SpaceID, TargetID, ToolchainType, UnitID, UpdatedAt, UpstreamOrganizationID, UpstreamRevisionNum, UpstreamSpaceID, UpstreamUnitID.
         *
         * Finding all units created by cloning can be done using the expression `UpstreamRevisionNum > 0`. Clones of a specific unit can be found by additionally filtering based on `UpstreamUnitID`. Unapplied units can be found using `LiveRevisionNum = 0`. Units with unapplied changes can be found with `HeadRevisionNum > LiveRevisionNum`.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
        /**
         * Include clause for expanding related entities in the response for Unit.
         * The attribute names are case-sensitive, PascalCase, and
         * expected in a comma-separated list format as in the JSON encoding.
         *
         * Supported attributes for Unit are ApprovedBy, HeadMutationNum, HeadRevisionNum, LastAppliedRevisionNum, LiveRevisionNum, OrganizationID, SetID, SpaceID, TargetID, UnitEventID, UpstreamSpaceID, UpstreamUnitID.
         *
         * The whole string must be query-encoded.
         */
        include?: string;
        /**
         * Resource type: Resource type to match for the desired ToolchainType, for example apps/v1/Deployment
         */
        resource_type?: string;
        /**
         * Where data filter: The specified string is an expression for the purpose of evaluating whether the configuration data matches the filter. The expression syntax was inspired by SQL. It supports conjunctions using `AND` of relational expressions of the form *path* *operator* *literal*. The path specifications are dot-separated, for both map fields and array indices, as in `spec.template.spec.containers.0.image = 'ghcr.io/headlamp-k8s/headlamp:latest' AND spec.replicas > 1`. Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`. Boolean values support equality and inequality only. String literals are quoted with single quotes, such as `'string'`. Integer and boolean literals are also supported for attributes of those types. The whole string must be query-encoded.
         */
        where_data?: string;
    };
    url: '/unit';
};

export type ListAllUnitsErrors = {
    /**
     * Unit request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * Unit not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing Unit.
     */
    500: StandardErrorResponse;
    default: Array<ExtendedUnit>;
};

export type ListAllUnitsError = ListAllUnitsErrors[keyof ListAllUnitsErrors];

export type ListAllUnitsResponses = {
    /**
     * OK
     */
    200: Array<ExtendedUnit>;
};

export type ListAllUnitsResponse = ListAllUnitsResponses[keyof ListAllUnitsResponses];

export type ListUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The specified string is an expression for the purpose of filtering
         * the list of Units returned. The expression syntax was inspired by SQL.
         * It supports conjunctions using `AND` of relational expressions of the form *attribute*
         * *operator* *attribute_or_literal*. The attribute names are case-sensitive and PascalCase,
         * as in the JSON encoding.
         * Strings and integers support the following operators: `<`, `>`, `<=`, `>=`, `=`, `!=`.
         * UUIDs and boolean attributes support equality and inequality only.
         * UUID and time literals must be quoted as string literals.
         * String literals are quoted with single quotes, such as `'string'`.
         * Time literals use the same form as when serialized as JSON,
         * such as: `CreatedAt > '2025-02-18T23:16:34'`.
         * Integer and boolean literals are also supported for attributes of those types.
         * Arrays support the `?` operator to to match any element of the array,
         * as in `ApprovedBy ? '7c61626f-ddbe-41af-93f6-b69f4ab6d308'`.
         * Arrays can perform LEN() to check for length, as in `LEN(ApprovedBy) > 0`.
         * Map support the dot notation to specify a particular map key, as in `Labels.tier = 'Backend'`.
         * Conjunctions are supported using the `AND` operator.
         * An example conjunction is:
         * `CreatedAt >= '2025-01-07' AND DisplayName = 'testunit' AND Labels.mykey = 'myvalue'`.
         *
         * Supported attributes for filtering on User: CreatedAt, DisplayName, ExternalID, Slug, UpdatedAt, UserID, Username.
         *
         * The whole string must be query-encoded.
         */
        where?: string;
    };
    url: '/user';
};

export type ListUsersErrors = {
    /**
     * User request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * User not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing User.
     */
    500: StandardErrorResponse;
    default: Array<User>;
};

export type ListUsersError = ListUsersErrors[keyof ListUsersErrors];

export type ListUsersResponses = {
    /**
     * OK
     */
    200: Array<User>;
};

export type ListUsersResponse = ListUsersResponses[keyof ListUsersResponses];

export type GetUserData = {
    body?: never;
    path: {
        /**
         * Unique identifier for a user_id
         */
        user_id: string;
    };
    query?: never;
    url: '/user/{user_id}';
};

export type GetUserErrors = {
    /**
     * User request is invalid (Bad Request).
     */
    400: StandardErrorResponse;
    /**
     * Unauthorized access.
     */
    401: StandardErrorResponse;
    /**
     * Forbidden access.
     */
    403: StandardErrorResponse;
    /**
     * User not found.
     */
    404: StandardErrorResponse;
    /**
     * Something went wrong while processing User.
     */
    500: StandardErrorResponse;
    /**
     * a User in Confighub.
     */
    default: User;
};

export type GetUserError = GetUserErrors[keyof GetUserErrors];

export type GetUserResponses = {
    /**
     * a User in Confighub.
     */
    200: User;
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type ClientOptions = {
    baseUrl: 'https://hub.confighub.com/api' | 'http://localhost:9090/api' | (string & {});
};