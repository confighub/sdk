// Copyright (C) ConfigHub, Inc.
// SPDX-License-Identifier: MIT

// Code generated by go-swagger; DO NOT EDIT.
package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ModelsUnit models unit
//
// swagger:model models.Unit
type ModelsUnit struct {

	// annotations
	Annotations map[string]string `json:"Annotations,omitempty"`

	// apply gates
	ApplyGates map[string]bool `json:"ApplyGates,omitempty"`

	// users that have approved the latest revision of the config data
	ApprovedBy []string `json:"ApprovedBy"`

	// data storage: Hash of this revision's data; only recompute in Update
	ContentHash int64 `json:"ContentHash,omitempty"`

	// CreatedAt is the timestamp when the entity was created in "2023-01-01T12:00:00Z" format.
	// Example: 2025-04-04T11:50:02.95102-07:00
	CreatedAt string `json:"CreatedAt,omitempty"`

	// CursorID is an auto-incrementing sequence number used for pagination.
	CursorID int64 `json:"CursorID,omitempty"`

	// Data contains the current configuration data for this unit.
	// This is typically a YAML, JSON, or HCL document defining resources.
	// Format: byte
	Data strfmt.Base64 `json:"Data,omitempty"`

	// not URL-safe
	DisplayName string `json:"DisplayName,omitempty"`

	// the sequence number of the head mutation
	HeadMutationNum int64 `json:"HeadMutationNum,omitempty"`

	// the sequence number of the head revision
	HeadRevisionNum int64 `json:"HeadRevisionNum,omitempty"`

	// labels
	Labels map[string]string `json:"Labels,omitempty"`

	// the sequence number of the last revision applied. 0 if no live revision
	LastAppliedRevisionNum int64 `json:"LastAppliedRevisionNum,omitempty"`

	// LastChangeDescription is a human-readable description of the last change.
	// This description is copied to the new Revision when the Data is changed.
	// example: "Updated replica count to 3"
	LastChangeDescription string `json:"LastChangeDescription,omitempty"`

	// the sequence number of the live revision once apply has completed. 0 if there is no live revision
	LiveRevisionNum int64 `json:"LiveRevisionNum,omitempty"`

	// The current State of the system
	// Format: byte
	LiveState strfmt.Base64 `json:"LiveState,omitempty"`

	// fine-grained details regarding the sources of mutations to the config data
	MutationSources []*APIResourceMutation `json:"MutationSources"`

	// Child ID uniqueness is scoped to an organization
	OrganizationID string `json:"OrganizationID,omitempty"`

	// The outputs from the last successful apply
	// Format: byte
	Outputs strfmt.Base64 `json:"Outputs,omitempty"`

	// the sequence number of the previous live revision once apply has completed
	PreviousLiveRevisionNum int64 `json:"PreviousLiveRevisionNum,omitempty"`

	// SetID is the identifier of the set this unit belongs to.
	// Sets are used to group related units together.
	// Optional. Units are not required to belong to sets.
	// Cleared automatically when the Set is deleted.
	// example: "123e4567-e89b-12d3-a456-426614174002"
	SetID string `json:"SetID,omitempty"`

	// URL-safe; must be unique within the same container hierarchy
	Slug string `json:"Slug,omitempty"`

	// space ID
	SpaceID string `json:"SpaceID,omitempty"`

	// TargetID is the identifier of the target this unit is associated with.
	// This defines where the configuration will be applied.
	// It must be set to a valid Target within the same Space before the Unit can be Applied, Destroyed, Imported, or Refreshed.
	// example: "123e4567-e89b-12d3-a456-426614174001"
	TargetID string `json:"TargetID,omitempty"`

	// ToolchainType specifies the type of toolchain for this unit.
	// Possible values include "Kubernetes/YAML", "OpenTofu/HCL".
	// required: true
	// example: "Kubernetes/YAML"
	ToolchainType string `json:"ToolchainType,omitempty"`

	// UnitID is the unique identifier for this unit.
	UnitID string `json:"UnitID,omitempty"`

	// UpdatedAt is the timestamp when the entity was last updated in "2023-01-01T12:00:00Z" format.
	// Example: 2025-04-04T11:50:02.95102-07:00
	UpdatedAt string `json:"UpdatedAt,omitempty"`

	// upstream organization ID
	UpstreamOrganizationID string `json:"UpstreamOrganizationID,omitempty"`

	// upstream revision num
	UpstreamRevisionNum int64 `json:"UpstreamRevisionNum,omitempty"`

	// upstream space ID
	UpstreamSpaceID string `json:"UpstreamSpaceID,omitempty"`

	// upstream unit ID
	UpstreamUnitID string `json:"UpstreamUnitID,omitempty"`

	// Version is an entity-specific sequence number used for optimistic concurrency control.
	// The value read must be sent in calls to Update.
	Version int64 `json:"Version,omitempty"`
}

// Validate validates this models unit
func (m *ModelsUnit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMutationSources(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ModelsUnit) validateMutationSources(formats strfmt.Registry) error {
	if swag.IsZero(m.MutationSources) { // not required
		return nil
	}

	for i := 0; i < len(m.MutationSources); i++ {
		if swag.IsZero(m.MutationSources[i]) { // not required
			continue
		}

		if m.MutationSources[i] != nil {
			if err := m.MutationSources[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("MutationSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("MutationSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this models unit based on the context it is used
func (m *ModelsUnit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMutationSources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ModelsUnit) contextValidateMutationSources(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MutationSources); i++ {

		if m.MutationSources[i] != nil {

			if swag.IsZero(m.MutationSources[i]) { // not required
				return nil
			}

			if err := m.MutationSources[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("MutationSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("MutationSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ModelsUnit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ModelsUnit) UnmarshalBinary(b []byte) error {
	var res ModelsUnit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
